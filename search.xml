<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode买卖股票</title>
    <url>/2020/09/19/leetcode%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/</url>
    <content><![CDATA[<p><img src="/2020/09/19/leetcode%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/121.png" alt></p><p>方法1：我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。</p><a id="more"></a>

<p>所以对于第二个数组我们可以暴力查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = i; i1 &lt; prices.length; i1++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i1]&lt;prices[i])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp =prices[i1]-prices[i];</span><br><span class="line">                    <span class="keyword">if</span>(temp&gt;max)max = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法2：动态规划解法。</p>
<p>动态规划方程为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前获得的最大利润为不售出(dp[i - 1])以及售出股票(prices[i] - minPrice)两者之间的较大者。</span><br><span class="line">dp[i] = Math.max(dp[i - 1], prices[i] - minPrice)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">int</span> minprice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            minprice = Math.min(minprice, prices[i]);</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], prices[i] - minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：其实并不太需要dp数组记录那么多数据，只需要记录在数组的每个数之前的最小值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = Integer.MAX_VALUE, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            minPrice = Math.min(minPrice, price);</span><br><span class="line">            res = Math.max(res, price - minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：单调栈（专门解决某个值左侧或右侧的极大或极小值）。</p>
<ol>
<li>必须使用双端队列，因为需要使用到栈底元素。</li>
<li>我们的数组必须在队尾增加一个哨兵元素，这里是-1，只要是一个值小于数组中的最小值即可，用于标识数组已经遍历结束。</li>
<li>假如栈空或入栈的元素的大于栈顶元素，直接入栈。</li>
<li>假如入栈元素小于栈顶元素则一直弹栈到入栈元素大于栈顶元素或栈空。</li>
<li>每次弹栈的时候，比较栈顶与栈底之差（即卖出与买入之差），维护一个最大值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] prices2 = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(prices, <span class="number">0</span>, prices2, <span class="number">0</span>, prices.length);</span><br><span class="line">        prices2[prices.length] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; prices2[i] &lt; stack.peekLast()) &#123;</span><br><span class="line">                res = Math.max(res, stack.peekLast() - stack.peekFirst());</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(prices2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/2020/09/19/leetcode%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/122.png" alt></p>
<p>可以无限次买卖的话，只要记录每次数组增大的幅度即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i + <span class="number">1</span>] &gt; prices[i])</span><br><span class="line">                res += (prices[i + <span class="number">1</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2020/09/19/leetcode%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/123.png" alt></p>
<p>方法一：限制买卖次数的话，就比较复杂了，递归解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//纯递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(prices, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// day表示日期， status表示当前股票的持有情况（0 不持有， 1 持有） k表示当前的交易数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> day, <span class="keyword">int</span> status, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (day == prices.length || k == <span class="number">2</span>)<span class="comment">//递归终止条件，日期结束或者交易数量达到2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;<span class="comment">// 分别表示持有，卖出， 以及买入能获得的最大收益</span></span><br><span class="line">        a = dfs(prices, day + <span class="number">1</span>, status, k);<span class="comment">//持有的最大收益</span></span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">1</span>) &#123;<span class="comment">//status == 1，表示当前持有股票</span></span><br><span class="line">            b = dfs(prices, day + <span class="number">1</span>, <span class="number">0</span>, k + <span class="number">1</span>) + prices[day];<span class="comment">// 选择卖出当前股票的收益（+当天股票价格），并且交易数量+1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// status == 0 当前没有股票</span></span><br><span class="line">            c = dfs(prices, day + <span class="number">1</span>, <span class="number">1</span>, k) - prices[day];<span class="comment">// 选择买入股票，收益-当前股票价格，status变为1表示持有股票，交易数不变</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(a, Math.max(b, c));<span class="comment">// 返回选择三种状态所能获得的最大收益</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优化：备忘录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备忘录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(prices, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// day表示日期， status表示当前股票的持有情况（0 不持有， 1 持有） k表示当前的交易数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> day, <span class="keyword">int</span> status, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (day == prices.length || k == <span class="number">2</span>)<span class="comment">//递归终止条件，日期结束或者交易数量达到2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[day][status][k] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[day][status][k];</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;<span class="comment">// 分别表示持有，卖出， 以及买入能获得的最大收益</span></span><br><span class="line">        a = dfs(prices, day + <span class="number">1</span>, status, k);<span class="comment">//持有的最大收益</span></span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">1</span>) &#123;<span class="comment">//status == 1，表示当前持有股票</span></span><br><span class="line">            b = dfs(prices, day + <span class="number">1</span>, <span class="number">0</span>, k + <span class="number">1</span>) + prices[day];<span class="comment">// 选择卖出当前股票的收益（+当天股票价格），并且交易数量+1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// status == 0 当前没有股票</span></span><br><span class="line">            c = dfs(prices, day + <span class="number">1</span>, <span class="number">1</span>, k) - prices[day];<span class="comment">// 选择买入股票，收益-当前股票价格，status变为1表示持有股票，交易数不变</span></span><br><span class="line">        &#125;</span><br><span class="line">        memo[day][status][k] = Math.max(a, Math.max(b, c));</span><br><span class="line">        <span class="keyword">return</span> memo[day][status][k];<span class="comment">// 返回选择三种状态所能获得的最大收益</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建类并使用map记录的备忘录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="comment">//用一个哈希表缓存重复的调用</span></span><br><span class="line">        Map&lt;Key,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Key,Integer&gt;();</span><br><span class="line">        <span class="keyword">return</span> dfs(map,prices,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Map&lt;Key,Integer&gt; map,<span class="keyword">int</span>[] prices,<span class="keyword">int</span> index,<span class="keyword">int</span> status,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Key key = <span class="keyword">new</span> Key(index,status,k);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==prices.length || k==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">        a = dfs(map,prices,index+<span class="number">1</span>,status,k);</span><br><span class="line">        <span class="keyword">if</span>(status==<span class="number">1</span>) &#123;</span><br><span class="line">            b = dfs(map,prices,index+<span class="number">1</span>,<span class="number">0</span>,k+<span class="number">1</span>)+prices[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          c = dfs(map,prices,index+<span class="number">1</span>,<span class="number">1</span>,k)-prices[index];</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, Math.max(Math.max(a,b),c) );</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">	  <span class="comment">//Key对象封装了index、status、交易次数，作为map的key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> k;</span><br><span class="line">        Key(<span class="keyword">int</span> index,<span class="keyword">int</span> status,<span class="keyword">int</span> k) &#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.status = status;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里需要实现自定义的equals和hashCode函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.index + <span class="keyword">this</span>.status + <span class="keyword">this</span>.k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            Key other = (Key)obj;</span><br><span class="line">            <span class="keyword">if</span>(index==other.index &amp;&amp; status==other.status &amp;&amp; k==other.k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终方法：跟第一题类似，不同的是把第二次的购入成本设置为当前值减去第一次购买的收益。（也可以理解为第一次购买得到的最终收益需要补贴一部分到第二次购买）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstBuy = Integer.MAX_VALUE, secondBuy = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> firstSell = <span class="number">0</span>, secondSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            firstBuy = Math.min(firstBuy, price);</span><br><span class="line">            firstSell = Math.max(firstSell, price - firstBuy);</span><br><span class="line">            secondBuy = Math.min(secondBuy, price - firstSell);</span><br><span class="line">            secondSell = Math.max(secondSell, price - secondBuy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secondSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/2020/09/19/leetcode%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/188.png" alt></p>
<p>与上一题类似，需要存储k对购买价格与售出价格。但是需要有一个小优化，因为每次交易至少需要两天，当k&gt;=n/2时，即可以认为是无限次交易次数了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= prices.length / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (prices[i + <span class="number">1</span>] &gt; prices[i])</span><br><span class="line">                    res += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][<span class="number">0</span>] = Math.min(dp[i][<span class="number">0</span>], p);</span><br><span class="line">                    dp[i][<span class="number">1</span>] = Math.max(dp[i][<span class="number">1</span>], p - dp[i][<span class="number">0</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][<span class="number">0</span>] = Math.min(dp[i][<span class="number">0</span>], p - dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                    dp[i][<span class="number">1</span>] = Math.max(dp[i][<span class="number">1</span>], p - dp[i][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝链表和图</title>
    <url>/2020/08/12/photo/</url>
    <content><![CDATA[<p><img src="/2020/08/12/photo/linkedlist.png" alt></p><p>思路：先复制链表的头结点，将头结点和新节点放入map中，后续节点的随机节点如若指向该节点即可直接找到，递归的复制头结点的下一个节点以及随机节点。</p><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//克隆以head为头结点的链表返回新链表的头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(head))</span><br><span class="line">            <span class="keyword">return</span> map.get(head);</span><br><span class="line">        Node tmp = <span class="keyword">new</span> Node(head.val);<span class="comment">//复制一份头结点</span></span><br><span class="line">        map.put(head,tmp);<span class="comment">// 【老节点，新节点】</span></span><br><span class="line">        tmp.next = copyRandomList(head.next);</span><br><span class="line">        tmp.random = copyRandomList(head.random);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/photo/graph.png" alt></p>
<p>思路：同链表类似，链表的头结点和随机节点=&gt;图的相邻节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(node))</span><br><span class="line">            <span class="keyword">return</span> map.get(node);</span><br><span class="line">        Node tmp = <span class="keyword">new</span> Node(node.val,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        map.put(node,tmp);</span><br><span class="line">        <span class="keyword">for</span>(Node n:node.neighbors)&#123;</span><br><span class="line">            tmp.neighbors.add(cloneGraph(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>map 递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode环形链表</title>
    <url>/2020/08/11/leetcode%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><img src="/imgs/leetcode/1.png" alt></p><p>思路1：利用哈希表存储访问过的节点，如若访问到哈希表已有的节点说明有环，如若指针指向空，循环结束，说明无环。空间复杂度为O(n).</p><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(cur))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            set.add(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：利用快慢指针同时移动，如若在某一时刻快慢指针相等，说明有环，如若快指针指向空，说明无环。空间复杂度为O(1).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode slow = head,fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/leetcode/2.png" alt></p>
<p>思路1：同上依然可以使用哈希表存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(cur))</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            set.add(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：利用快慢指针但是需要一些推理。</p>
<p>首先，可以确定快慢指针相遇肯定在环中，设头结点到环入口的长度为a，此时设慢指针走过的路程为x，那么快指针走过的路程为2x，环的长度为b，那么有<code>2x-x = k*b</code>，其中k为大于等于1的正整数，即存在<code>x = k*b</code>，意思是慢指针走过的路程一定是环长度的整数倍，让此时的慢指针再走a距离，此时有<code>x+a = k*b+a</code>，可知此时的慢指针一定指向环的入口。</p>
<p><img src="/imgs/leetcode/3.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head,fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                ListNode tmp = slow;</span><br><span class="line">                ListNode q = head;</span><br><span class="line">                <span class="keyword">while</span>(q!=tmp)&#123;</span><br><span class="line">                    q = q.next;</span><br><span class="line">                    tmp = tmp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>环形链表 快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始学java-5</title>
    <url>/2019/11/29/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6java-5/</url>
    <content><![CDATA[<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><h4 id="1-Object类介绍"><a href="#1-Object类介绍" class="headerlink" title="1.Object类介绍"></a>1.Object类介绍</h4><p>Object类是所有类的的父类。一个类都会直接或者间接的继承自该类。</p><a id="more"></a>
<p>该类中提供了一些非常常用的方法。</p>
<h4 id="2-toString-方法"><a href="#2-toString-方法" class="headerlink" title="2.toString()方法"></a>2.toString()方法</h4><p>A:作用：带引对象的信息</p>
<p>B:重写前：打印的是包名类名@地址值</p>
<p>C:重写后：打印的是对象中的属性值</p>
<h4 id="3-equals-方法"><a href="#3-equals-方法" class="headerlink" title="3.equals()方法"></a>3.equals()方法</h4><p>A:作用：比较两个对象</p>
<p>B:重写前：比较的是对象的地址值</p>
<p>C重写后：比较的是对象中的属性值</p>
<h2 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h2><h4 id="1-Date类"><a href="#1-Date类" class="headerlink" title="1.Date类"></a>1.Date类</h4><p>  A.构造方法</p>
<p>​    Date();根据当前系统时间创建日期对象</p>
<p>​    Date(long time);根据传入的毫秒值时间创建日期对象</p>
<p>B.成员方法</p>
<p>​    long getTime(); 获取当前日期对象的毫秒值时间</p>
<p>​    String toLocaleString();根据本地格式转换日期对象</p>
<h4 id="2-DateFormat类-amp-SimpleDateFormat类"><a href="#2-DateFormat类-amp-SimpleDateFormat类" class="headerlink" title="2.DateFormat类&amp;SimpleDateFormat类"></a>2.DateFormat类&amp;SimpleDateFormat类</h4><p>A.构造方法</p>
<p>​    SimpleDateFormat(String s);根据指定模板穿件日期格式化对象</p>
<p>B.成员方法</p>
<p>​    String format(Date d); 根据指定格式格式化日期对象</p>
<p>​    Data parse(String s); 根据指定格式解析字符串</p>
<h4 id="3-Calendar类"><a href="#3-Calendar类" class="headerlink" title="3.Calendar类"></a>3.Calendar类</h4><p>A.创建对象方式</p>
<p>​    Calendar c = Calendar.newInstance(); 获取日历类对象</p>
<p>B.成员方法</p>
<p>​    int get(int n); 获取指定日历字段信息</p>
<p>​    void set(int n,int value); 将制定日历字段设置为指定的值</p>
<p>​    void add(int n,int value); 将制定日历字段增加或者减少指定的值</p>
<h2 id="Syetem类"><a href="#Syetem类" class="headerlink" title="Syetem类"></a>Syetem类</h2><h4 id="1-currentTimeMills-方法"><a href="#1-currentTimeMills-方法" class="headerlink" title="1.currentTimeMills()方法"></a>1.currentTimeMills()方法</h4><p>​    作用：获取当前系统毫秒值时间</p>
<h4 id="2-arraycopy-方法"><a href="#2-arraycopy-方法" class="headerlink" title="2.arraycopy()方法"></a>2.arraycopy()方法</h4><p>​    作用：复制数组</p>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><p>​    StringBuilder(); 创建一个空的字符串缓冲区对象</p>
<p>​    StringBuilder(String s); 根据传入的内容创建一个字符串缓冲区对象</p>
<h4 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><p>​    StringBuilder append(Object obj); 添加内容</p>
<p>​    StringBuilder reverse();反转内容</p>
<p>​    String toString(); 将缓存区内容转为字符串</p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h4 id="1-基本数据-类型对应的包装类"><a href="#1-基本数据-类型对应的包装类" class="headerlink" title="1.基本数据 类型对应的包装类"></a>1.基本数据 类型对应的包装类</h4><p>​    byte                Byte</p>
<p>​    short              Short</p>
<p>​    int                  Integer</p>
<p>​    char               Character</p>
<p>​    double          Double    </p>
<p>​    float                Float</p>
<p>​    long                 Long</p>
<p>​    boolean        Boolean</p>
<p>​    </p>
<h4 id="2-数字转为字符串"><a href="#2-数字转为字符串" class="headerlink" title="2.数字转为字符串"></a>2.数字转为字符串</h4><ol>
<li><p>值+“””    最简单的方式</p>
</li>
<li><p>Integer中的静态方法     static String toStirng(int i )   返回一个表示指定整数的String对象 </p>
</li>
<li><p>String类中的静态方法    static String valueOf(int i )返回int阐述的字符串表示形式。</p>
<p>​     </p>
</li>
</ol>
<h4 id="3-字符串转为数字"><a href="#3-字符串转为数字" class="headerlink" title="3.字符串转为数字"></a>3.字符串转为数字</h4><p>使用包装类中的parseXX(String s)方法</p>
<p>​        Integer类： static int parseInt(String s)</p>
<p>​        Double类：static double parseDouble(String s)</p>
<h4 id="4-自动拆装箱"><a href="#4-自动拆装箱" class="headerlink" title="4.自动拆装箱"></a>4.自动拆装箱</h4>]]></content>
      <categories>
        <category>learn java</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始学java-4</title>
    <url>/2019/11/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6java-4/</url>
    <content><![CDATA[<h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><h4 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在任何版本的Java中，接口都能定义抽象方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public abstract 返回值类型 方法名称(参数列表);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract</span></span><br><span class="line"><span class="comment">2. 这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。）</span></span><br><span class="line"><span class="comment">3. 方法的三要素，可以随意定义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceAbstract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这也是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这也是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这也是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodAbs4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接口就是多个类的公共规范。</span></span><br><span class="line"><span class="comment">接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如何定义一个接口的格式：</span></span><br><span class="line"><span class="comment">public interface 接口名称 &#123;</span></span><br><span class="line"><span class="comment">    // 接口内容</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java --&gt; .class。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果是Java 7，那么接口中可以包含的内容有：</span></span><br><span class="line"><span class="comment">1. 常量</span></span><br><span class="line"><span class="comment">2. 抽象方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果是Java 8，还可以额外包含有：</span></span><br><span class="line"><span class="comment">3. 默认方法</span></span><br><span class="line"><span class="comment">4. 静态方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果是Java 9，还可以额外包含有：</span></span><br><span class="line"><span class="comment">5. 私有方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接口使用步骤：</span></span><br><span class="line"><span class="comment">1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public class 实现类名称 implements 接口名称 &#123;</span></span><br><span class="line"><span class="comment">    // ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。</span></span><br><span class="line"><span class="comment">实现：去掉abstract关键字，加上方法体大括号。</span></span><br><span class="line"><span class="comment">3. 创建实现类的对象，进行使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 错误写法！不能直接new接口对象使用。</span></span><br><span class="line"><span class="comment">//        MyInterfaceAbstract inter = new MyInterfaceAbstract();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建实现类的对象使用</span></span><br><span class="line">        MyInterfaceAbstractImpl impl = <span class="keyword">new</span> MyInterfaceAbstractImpl();</span><br><span class="line">        impl.methodAbs1();</span><br><span class="line">        impl.methodAbs2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<h4 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从Java 8开始，接口里允许定义默认方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public default 返回值类型 方法名称(参数列表) &#123;</span></span><br><span class="line"><span class="comment">    方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">备注：接口当中的默认方法，可以解决接口升级的问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceDefault</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新添加了一个抽象方法</span></span><br><span class="line"><span class="comment">//    public abstract void methodAbs2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新添加的方法，改成默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是新添加的默认方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceDefaultA</span> <span class="keyword">implements</span> <span class="title">MyInterfaceDefault</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现了抽象方法，AAA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceDefaultB</span> <span class="keyword">implements</span> <span class="title">MyInterfaceDefault</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现了抽象方法，BBB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 实现类B覆盖重写了接口的默认方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 接口的默认方法，可以通过接口实现类对象，直接调用。</span></span><br><span class="line"><span class="comment">2. 接口的默认方法，也可以被接口实现类进行覆盖重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建了实现类对象</span></span><br><span class="line">        MyInterfaceDefaultA a = <span class="keyword">new</span> MyInterfaceDefaultA();</span><br><span class="line">        a.methodAbs(); <span class="comment">// 调用抽象方法，实际运行的是右侧实现类。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用默认方法，如果实现类当中没有，会向上找接口</span></span><br><span class="line">        a.methodDefault(); <span class="comment">// 这是新添加的默认方法</span></span><br><span class="line">        System.out.println(<span class="string">"=========="</span>);</span><br><span class="line"></span><br><span class="line">        MyInterfaceDefaultB b = <span class="keyword">new</span> MyInterfaceDefaultB();</span><br><span class="line">        b.methodAbs();</span><br><span class="line">        b.methodDefault(); <span class="comment">// 实现类B覆盖重写了接口的默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="接口的静态方法"><a href="#接口的静态方法" class="headerlink" title="接口的静态方法"></a>接口的静态方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从Java 8开始，接口当中允许定义静态方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static 返回值类型 方法名称(参数列表) &#123;</span></span><br><span class="line"><span class="comment">    方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">提示：就是将abstract或者default换成static即可，带上方法体。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceStatic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是接口的静态方法！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceStaticImpl</span> <span class="keyword">implements</span> <span class="title">MyInterfaceStatic</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyInterfacePrivateB.methodStatic1();</span><br><span class="line">        MyInterfacePrivateB.methodStatic2();</span><br><span class="line">        <span class="comment">// 错误写法！</span></span><br><span class="line"><span class="comment">//        MyInterfacePrivateB.methodStaticCommon();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口的私有方法（java9才有）"><a href="#接口的私有方法（java9才有）" class="headerlink" title="接口的私有方法（java9才有）"></a>接口的私有方法（java9才有）</h4><h4 id="接口的成员变量"><a href="#接口的成员变量" class="headerlink" title="接口的成员变量"></a>接口的成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。</span></span><br><span class="line"><span class="comment">从效果上看，这其实就是接口的【常量】。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static final 数据类型 常量名称 = 数据值;</span></span><br><span class="line"><span class="comment">备注：</span></span><br><span class="line"><span class="comment">一旦使用final关键字进行修饰，说明不可改变。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1. 接口当中的常量，可以省略public static final，注意：不写也照样是这样。</span></span><br><span class="line"><span class="comment">2. 接口当中的常量，必须进行赋值；不能不赋值。</span></span><br><span class="line"><span class="comment">3. 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceConst</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这其实就是一个常量，一旦赋值，不可以修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_OF_MY_CLASS = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="接口小结"><a href="#接口小结" class="headerlink" title="接口小结"></a>接口小结</h4><p>在Java 9+版本中，接口的内容可以有：</p>
<ol>
<li><p>成员变量其实是常量，格式：<br>[public] [static] [final] 数据类型 常量名称 = 数据值;<br>注意：<br> 常量必须进行赋值，而且一旦赋值不能改变。<br> 常量名称完全大写，用下划线进行分隔。</p>
</li>
<li><p>接口中最重要的就是抽象方法，格式：<br>[public] [abstract] 返回值类型 方法名称(参数列表);<br>注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。</p>
</li>
<li><p>从Java 8开始，接口里允许定义默认方法，格式：<br>[public] default 返回值类型 方法名称(参数列表) { 方法体 }<br>注意：默认方法也可以被覆盖重写</p>
</li>
<li><p>从Java 8开始，接口里允许定义静态方法，格式：<br>[public] static 返回值类型 方法名称(参数列表) { 方法体 }<br>注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</p>
</li>
<li><p>从Java 9开始，接口里允许定义私有很乏，格式：<br>普通私有方法：private 返回值类型 方法名称(参数列表) { 方法体 }<br>静态私有方法：private static 返回值类型 方法名称(参数列表) { 方法体 }<br>注意：private的方法只有接口自己才能调用，不能被实现类或别人使用。</p>
</li>
</ol>
<h4 id="接口的注意事项"><a href="#接口的注意事项" class="headerlink" title="接口的注意事项"></a>接口的注意事项</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用接口的时候，需要注意：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 接口是没有静态代码块或者构造方法的。</span></span><br><span class="line"><span class="comment">2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB &#123;</span></span><br><span class="line"><span class="comment">    // 覆盖重写所有抽象方法</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</span></span><br><span class="line"><span class="comment">4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</span></span><br><span class="line"><span class="comment">5. 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</span></span><br><span class="line"><span class="comment">6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码当中体现多态性，其实就是一句话：父类引用指向子类对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">父类名称 对象名 = new 子类名称();</span></span><br><span class="line"><span class="comment">或者：</span></span><br><span class="line"><span class="comment">接口名称 对象名 = new 实现类名称();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Multi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态的写法</span></span><br><span class="line">        <span class="comment">// 左侧父类的引用，指向了右侧子类的对象</span></span><br><span class="line">        Fu obj = <span class="keyword">new</span> Zi();</span><br><span class="line"></span><br><span class="line">        obj.method();</span><br><span class="line">        obj.methodFu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：方法是new哪个调用哪个，成员变量则是看等号左边哪个是哪个，没有的话向上找。</p>
<p>访问成员变量的两种方式：</p>
<p>1.直接通过成员变量访问成员变量，看等号左边是谁，优先用谁，没有则向上找。</p>
<p>2.间接通过成员方法访问成员变量，看该方法属于谁，优先用谁，没有则向上找。</p>
<h4 id="对象的向上转型和向下转型"><a href="#对象的向上转型和向下转型" class="headerlink" title="对象的向上转型和向下转型"></a>对象的向上转型和向下转型</h4><p><img src="/blog/imgs/java/zhuanxin.png" alt></p>
<h4 id="instanceof的使用"><a href="#instanceof的使用" class="headerlink" title="instanceof的使用"></a>instanceof的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day10.demo06;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何才能知道一个父类引用的对象，本来是什么子类？</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">对象 instanceof 类名称</span></span><br><span class="line"><span class="comment">这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Instanceof</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Dog(); <span class="comment">// 本来是一只狗</span></span><br><span class="line">        animal.eat(); <span class="comment">// 狗吃SHIT</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果希望掉用子类特有方法，需要向下转型</span></span><br><span class="line">        <span class="comment">// 判断一下父类引用animal本来是不是Dog</span></span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            Dog dog = (Dog) animal;</span><br><span class="line">            dog.watchHouse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断一下animal本来是不是Cat</span></span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            Cat cat = (Cat) animal;</span><br><span class="line">            cat.catchMouse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        giveMeAPet(<span class="keyword">new</span> Dog());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveMeAPet</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            Dog dog = (Dog) animal;</span><br><span class="line">            dog.watchHouse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            Cat cat = (Cat) animal;</span><br><span class="line">            cat.catchMouse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="final的使用"><a href="#final的使用" class="headerlink" title="final的使用"></a>final的使用</h2><h2 id="4种权限修饰符"><a href="#4种权限修饰符" class="headerlink" title="4种权限修饰符"></a>4种权限修饰符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中有四种权限修饰符： public  &gt;   protected   &gt;   (default)   &gt;   private</span><br><span class="line">同一个类（我自己）        YES         YES             YES             YES</span><br><span class="line">同一个包（我邻居）        YES         YES             YES             NO</span><br><span class="line">不同包子类（我儿子）       YES         YES             NO              NO</span><br><span class="line">不同包非子类（陌生人）      YES         NO              NO              NO</span><br><span class="line">注意事项：(default)并不是关键字“default”，而是根本不写。</span><br></pre></td></tr></table></figure>



<h2 id="外部内中定义内部类"><a href="#外部内中定义内部类" class="headerlink" title="外部内中定义内部类"></a>外部内中定义内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day11.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。</span></span><br><span class="line"><span class="comment">例如：身体和心脏的关系。又如：汽车和发动机的关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">1. 成员内部类</span></span><br><span class="line"><span class="comment">2. 局部内部类（包含匿名内部类）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员内部类的定义格式：</span></span><br><span class="line"><span class="comment">修饰符 class 外部类名称 &#123;</span></span><br><span class="line"><span class="comment">    修饰符 class 内部类名称 &#123;</span></span><br><span class="line"><span class="comment">        // ...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    // ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：内用外，随意访问；外用内，需要内部类对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">==========================</span></span><br><span class="line"><span class="comment">如何使用成员内部类？有两种方式：</span></span><br><span class="line"><span class="comment">1. 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。</span></span><br><span class="line"><span class="comment">2. 直接方式，公式：</span></span><br><span class="line"><span class="comment">类名称 对象名 = new 类名称();</span></span><br><span class="line"><span class="comment">【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Body body = <span class="keyword">new</span> Body(); <span class="comment">// 外部类的对象</span></span><br><span class="line">        <span class="comment">// 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart</span></span><br><span class="line">        body.methodBody();</span><br><span class="line">        System.out.println(<span class="string">"====================="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照公式写：</span></span><br><span class="line">        Body.Heart heart = <span class="keyword">new</span> Body().<span class="keyword">new</span> Heart();</span><br><span class="line">        heart.beat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问重名的外部类对象"><a href="#访问重名的外部类对象" class="headerlink" title="访问重名的外部类对象"></a>访问重名的外部类对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day11.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 外部类的成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>; <span class="comment">// 内部类的成员变量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>; <span class="comment">// 内部类方法的局部变量</span></span><br><span class="line">            System.out.println(num); <span class="comment">// 局部变量，就近原则</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 内部类的成员变量</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num); <span class="comment">// 外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部内部类访问局部变量"><a href="#局部内部类访问局部变量" class="headerlink" title="局部内部类访问局部变量"></a>局部内部类访问局部变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day11.demo04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">原因：</span></span><br><span class="line"><span class="comment">1. new出来的对象在堆内存当中。</span></span><br><span class="line"><span class="comment">2. 局部变量是跟着方法走的，在栈内存当中。</span></span><br><span class="line"><span class="comment">3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。</span></span><br><span class="line"><span class="comment">4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOuter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 所在方法的局部变量</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyInner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day11.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，</span></span><br><span class="line"><span class="comment">那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名内部类的定义格式：</span></span><br><span class="line"><span class="comment">接口名称 对象名 = new 接口名称() &#123;</span></span><br><span class="line"><span class="comment">    // 覆盖重写所有抽象方法</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对格式“new 接口名称() &#123;...&#125;”进行解析：</span></span><br><span class="line"><span class="comment">1. new代表创建对象的动作</span></span><br><span class="line"><span class="comment">2. 接口名称就是匿名内部类需要实现哪个接口</span></span><br><span class="line"><span class="comment">3. &#123;...&#125;这才是匿名内部类的内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">另外还要注意几点问题：</span></span><br><span class="line"><span class="comment">1. 匿名内部类，在【创建对象】的时候，只能使用唯一一次。</span></span><br><span class="line"><span class="comment">如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。</span></span><br><span class="line"><span class="comment">2. 匿名对象，在【调用方法】的时候，只能调用唯一一次。</span></span><br><span class="line"><span class="comment">如果希望同一个对象，调用多次方法，那么必须给对象起个名字。</span></span><br><span class="line"><span class="comment">3. 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】</span></span><br><span class="line"><span class="comment">强调：匿名内部类和匿名对象不是一回事！！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        MyInterface obj = new MyInterfaceImpl();</span></span><br><span class="line"><span class="comment">//        obj.method();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        MyInterface some = new MyInterface(); // 错误写法！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用匿名内部类，但不是匿名对象，对象名称就叫objA</span></span><br><span class="line">        MyInterface objA = <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类实现了方法！111-A"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类实现了方法！222-A"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        objA.method1();</span><br><span class="line">        objA.method2();</span><br><span class="line">        System.out.println(<span class="string">"================="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用了匿名内部类，而且省略了对象名称，也是匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类实现了方法！111-B"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类实现了方法！222-B"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method1();</span><br><span class="line">        <span class="comment">// 因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类实现了方法！111-B"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类实现了方法！222-B"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learn java</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始学java-3</title>
    <url>/2019/11/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6java-3/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day09.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">直接通过子类对象访问成员变量：</span></span><br><span class="line"><span class="comment">    等号左边是谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment">间接通过成员方法访问成员变量：</span></span><br><span class="line"><span class="comment">    该方法属于谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ExtendsField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu fu = <span class="keyword">new</span> Fu(); <span class="comment">// 创建父类对象</span></span><br><span class="line">        System.out.println(fu.numFu); <span class="comment">// 只能使用父类的东西，没有任何子类内容</span></span><br><span class="line">        System.out.println(<span class="string">"==========="</span>);</span><br><span class="line"></span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line"></span><br><span class="line">        System.out.println(zi.numFu); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(zi.numZi); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(<span class="string">"==========="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等号左边是谁，就优先用谁</span></span><br><span class="line">        System.out.println(zi.num); <span class="comment">// 优先子类，200</span></span><br><span class="line"><span class="comment">//        System.out.println(zi.abc); // 到处都没有，编译报错！</span></span><br><span class="line">        System.out.println(<span class="string">"==========="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个方法是子类的，优先用子类的，没有再向上找</span></span><br><span class="line">        zi.methodZi(); <span class="comment">// 200</span></span><br><span class="line">        <span class="comment">// 这个方法是在父类当中定义的，</span></span><br><span class="line">        zi.methodFu(); <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>

<h4 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(@Override)"></a>重写(@Override)</h4><p>方法覆盖重写的注意事项：</p>
<ol>
<li><p>必须保证父子类之间方法的名称相同，参数列表也相同。<br>@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。<br>这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</p>
</li>
<li><p>子类方法的返回值必须【小于等于】父类方法的返回值范围。<br>小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</p>
</li>
<li><p>子类方法的权限必须【大于等于】父类方法的权限修饰符。<br>小扩展提示：public &gt; protected &gt; (default) &gt; private<br>备注：(default)不是关键字default，而是什么都不写，留空。</p>
</li>
</ol>
<h4 id="super的使用"><a href="#super的使用" class="headerlink" title="super的使用"></a>super的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day09.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 30，局部变量</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 20，本类的成员变量</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num); <span class="comment">// 10，父类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.day09.demo06;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个新手机，使用老手机作为父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show(); <span class="comment">// 把父类的show方法拿过来重复利用</span></span><br><span class="line">        <span class="comment">// 自己子类再来添加更多内容</span></span><br><span class="line">        System.out.println(<span class="string">"显示姓名"</span>);</span><br><span class="line">        System.out.println(<span class="string">"显示头像"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">继承关系中，父子类构造方法的访问特点：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。</span></span><br><span class="line"><span class="comment">2. 子类构造可以通过super关键字来调用父类重载构造。</span></span><br><span class="line"><span class="comment">3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.itcast.day09.demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 在调用父类无参构造方法</span></span><br><span class="line"><span class="comment">//        super(20); // 在调用父类重载的构造方法</span></span><br><span class="line">        System.out.println(<span class="string">"子类构造方法！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="super用法小结"><a href="#super用法小结" class="headerlink" title="super用法小结"></a>super用法小结</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day09.demo08;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super关键字的用法有三种：</span></span><br><span class="line"><span class="comment">1. 在子类的成员方法中，访问父类的成员变量。</span></span><br><span class="line"><span class="comment">2. 在子类的成员方法中，访问父类的成员方法。</span></span><br><span class="line"><span class="comment">3. 在子类的构造方法中，访问父类的构造方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodZi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num); <span class="comment">// 父类中的num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.method(); <span class="comment">// 访问父类中的method</span></span><br><span class="line">        System.out.println(<span class="string">"子类方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="this用法小结"><a href="#this用法小结" class="headerlink" title="this用法小结"></a>this用法小结</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day09.demo09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 在本类的成员方法中，访问本类的成员变量。</span></span><br><span class="line"><span class="comment">2. 在本类的成员方法中，访问本类的另一个成员方法。</span></span><br><span class="line"><span class="comment">3. 在本类的构造方法中，访问本类的另一个构造方法。</span></span><br><span class="line"><span class="comment">在第三种用法当中要注意：</span></span><br><span class="line"><span class="comment">A. this(...)调用也必须是构造方法的第一个语句，唯一一个。</span></span><br><span class="line"><span class="comment">B. super和this两种构造调用，不能同时使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        super(); // 这一行不再赠送</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="number">123</span>); <span class="comment">// 本类的无参构造，调用本类的有参构造</span></span><br><span class="line"><span class="comment">//        this(1, 2); // 错误写法！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 本类中的成员变量</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num); <span class="comment">// 父类中的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AAA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodA();</span><br><span class="line">        System.out.println(<span class="string">"BBB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="super和this内存图解"><a href="#super和this内存图解" class="headerlink" title="super和this内存图解"></a>super和this内存图解</h4><p>!(/blog/imgs/java/superthis.png)</p>
<h4 id="java单继承的特点"><a href="#java单继承的特点" class="headerlink" title="java单继承的特点"></a>java单继承的特点</h4><p>!(/blog/imgs/java/single.png)</p>
<hr>
<h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day09.demo11;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。</span></span><br><span class="line"><span class="comment">抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如何使用抽象类和抽象方法：</span></span><br><span class="line"><span class="comment">1. 不能直接创建new抽象类对象。</span></span><br><span class="line"><span class="comment">2. 必须用一个子类来继承抽象父类。</span></span><br><span class="line"><span class="comment">3. 子类必须覆盖重写抽象父类当中所有的抽象方法。</span></span><br><span class="line"><span class="comment">覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</span></span><br><span class="line"><span class="comment">4. 创建子类对象进行使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是普通的成员方法</span></span><br><span class="line"><span class="comment">//    public void normalMethod() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day09.demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day09.demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Animal animal = new Animal(); // 错误写法！不能直接创建抽象类对象</span></span><br><span class="line"></span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。 </p>
<ol>
<li>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</li>
<li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</li>
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</li>
<li>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象 类。 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有 意义。 </li>
</ol>
]]></content>
      <categories>
        <category>learn java</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始学java-2</title>
    <url>/2019/11/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6java-2/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的概念：是一种容器，可以同时存放多个数据值。</p><p>数组的特点：</p><ol>
<li>数组是一种引用数据类型</li>
<li>数组当中的多个数据，类型必须统一</li>
<li>数组的长度在程序运行期间不可改变</li>
</ol><a id="more"></a>


<p>数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。</p>
<p>两种常见的初始化方式：</p>
<ol>
<li>动态初始化（指定长度）</li>
<li>静态初始化（指定内容）</li>
</ol>
<p>动态初始化数组的格式：<br>数据类型[] 数组名称 = new 数据类型[数组长度];</p>
<p>解析含义：<br>左侧数据类型：也就是数组当中保存的数据，全都是统一的什么类型<br>左侧的中括号：代表我是一个数组<br>左侧数组名称：给数组取一个名字<br>右侧的new：代表创建数组的动作<br>右侧数据类型：必须和左边的数据类型保持一致<br>右侧中括号的长度：也就是数组当中，到底可以保存多少个数据，是一个int数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day05.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个数组，里面可以存放300个int数据</span></span><br><span class="line">        <span class="comment">// 格式：数据类型[] 数组名称 = new 数据类型[数组长度];</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组，能存放10个double类型的数据</span></span><br><span class="line">        <span class="keyword">double</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组，能存放5个字符串</span></span><br><span class="line">        String[] arrayC = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day05.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数。</span></span><br><span class="line"><span class="comment">静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">静态初始化基本格式：</span></span><br><span class="line"><span class="comment">数据类型[] 数组名称 = new 数据类型[] &#123; 元素1, 元素2, ... &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">虽然静态初始化没有直接告诉长度，但是根据大括号里面的元素具体内容，也可以自动推算出来长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接创建一个数组，里面装的全都是int数字，具体为：5、15、25</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">40</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组，用来装字符串："Hello"、"World"、"Java"</span></span><br><span class="line">        String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"Java"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day05.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用静态初始化数组的时候，格式还可以省略一下。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">标准格式：</span></span><br><span class="line"><span class="comment">数据类型[] 数组名称 = new 数据类型[] &#123; 元素1, 元素2, ... &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">省略格式：</span></span><br><span class="line"><span class="comment">数据类型[] 数组名称 = &#123; 元素1, 元素2, ... &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1. 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。</span></span><br><span class="line"><span class="comment">2. 静态初始化标准格式可以拆分成为两个步骤。</span></span><br><span class="line"><span class="comment">3. 动态初始化也可以拆分成为两个步骤。</span></span><br><span class="line"><span class="comment">4. 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用建议：</span></span><br><span class="line"><span class="comment">如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略格式的静态初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayA = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态初始化的标准格式，可以拆分成为两个步骤</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayB;</span><br><span class="line">        arrayB = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">11</span>, <span class="number">21</span>, <span class="number">31</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态初始化也可以拆分成为两个步骤</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayC;</span><br><span class="line">        arrayC = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态初始化的省略格式，不能拆分成为两个步骤。</span></span><br><span class="line"><span class="comment">//        int[] arrayD;</span></span><br><span class="line"><span class="comment">//        arrayD = &#123; 10, 20, 30 &#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day05.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则如下：</span></span><br><span class="line"><span class="comment">如果是整数类型，那么默认为0；</span></span><br><span class="line"><span class="comment">如果是浮点类型，那么默认为0.0；</span></span><br><span class="line"><span class="comment">如果是字符类型，那么默认为'\u0000'；</span></span><br><span class="line"><span class="comment">如果是布尔类型，那么默认为false；</span></span><br><span class="line"><span class="comment">如果是引用类型，那么默认为null。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05ArrayUse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态初始化一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(array); <span class="comment">// 内存地址值</span></span><br><span class="line">        System.out.println(array[<span class="number">0</span>]); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(array[<span class="number">1</span>]); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(array[<span class="number">2</span>]); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(<span class="string">"================="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据123赋值交给数组array当中的1号元素</span></span><br><span class="line">        array[<span class="number">1</span>] = <span class="number">123</span>;</span><br><span class="line">        System.out.println(array[<span class="number">0</span>]); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(array[<span class="number">1</span>]); <span class="comment">// 123</span></span><br><span class="line">        System.out.println(array[<span class="number">2</span>]); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java中内存的使用"><a href="#java中内存的使用" class="headerlink" title="java中内存的使用"></a>java中内存的使用</h4><p><img src="/blog/imgs/java/neicun.png" alt></p>
<hr>
<h2 id="Scanner的使用"><a href="#Scanner的使用" class="headerlink" title="Scanner的使用"></a>Scanner的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day07.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 1. 导包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Scanner类的功能：可以实现键盘输入数据，到程序当中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">引用类型的一般使用步骤：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 导包</span></span><br><span class="line"><span class="comment">import 包路径.类名称;</span></span><br><span class="line"><span class="comment">如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。</span></span><br><span class="line"><span class="comment">只有java.lang包下的内容不需要导包，其他的包都需要import语句。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 创建</span></span><br><span class="line"><span class="comment">类名称 对象名 = new 类名称();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 使用</span></span><br><span class="line"><span class="comment">对象名.成员方法名()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">获取键盘输入的一个int数字：int num = sc.nextInt();</span></span><br><span class="line"><span class="comment">获取键盘输入的一个字符串：String str = sc.next();</span></span><br><span class="line"><span class="comment">其实输入的都是字符串，nextInt会把字符串转为int而已。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Scanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 创建</span></span><br><span class="line">        <span class="comment">// 备注：System.in代表从键盘进行输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取键盘输入的int数字</span></span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"输入的int数字是："</span> + num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取键盘输入的字符串</span></span><br><span class="line">        String str = sc.next();</span><br><span class="line">        System.out.println(<span class="string">"输入的字符串是："</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名对象只能使用一次，可以作为函数的参数或者返回值使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="keyword">new</span> scanner(System.in).netInt();<span class="comment">//只想输入一个数时使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodParam</span><span class="params">(Scanner sc)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title">methodReturn</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Scanner(System.in);&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Random的使用"><a href="#Random的使用" class="headerlink" title="Random的使用"></a>Random的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day07.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Random类用来生成随机数字。使用起来也是三个步骤：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 导包</span></span><br><span class="line"><span class="comment">import java.util.Random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 创建</span></span><br><span class="line"><span class="comment">Random r = new Random(); // 小括号当中留空即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 使用</span></span><br><span class="line"><span class="comment">获取一个随机的int数字（范围是int所有范围，有正负两种）：int num = r.nextInt()</span></span><br><span class="line"><span class="comment">获取一个随机的int数字（参数代表了范围，左闭右开区间）：int num = r.nextInt(3)</span></span><br><span class="line"><span class="comment">实际上代表的含义是：[0,3)，也就是0~2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Random</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = r.nextInt();</span><br><span class="line">        <span class="keyword">int</span> num2 = r.nextInt(<span class="number">10</span>);<span class="comment">//获得0——9的随机数</span></span><br><span class="line">        System.out.println(<span class="string">"随机数是："</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ArrayList的使用"><a href="#ArrayList的使用" class="headerlink" title="ArrayList的使用"></a>ArrayList的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day07.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组的长度不可以发生改变。</span></span><br><span class="line"><span class="comment">但是ArrayList集合的长度是可以随意变化的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于ArrayList来说，有一个尖括号&lt;E&gt;代表泛型。</span></span><br><span class="line"><span class="comment">泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。</span></span><br><span class="line"><span class="comment">注意：泛型只能是引用类型，不能是基本类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。</span></span><br><span class="line"><span class="comment">如果内容是空，得到的是空的中括号：[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02ArrayList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建了一个ArrayList集合，集合的名称是list，里面装的全都是String字符串类型的数据</span></span><br><span class="line">        <span class="comment">// 备注：从JDK 1.7+开始，右侧的尖括号内部可以不写内容，但是&lt;&gt;本身还是要写的。</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(list); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向集合当中添加一些数据，需要用到add方法。</span></span><br><span class="line">        list.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [赵丽颖]</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        list.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        list.add(<span class="string">"玛尔扎哈"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        list.add(100); // 错误写法！因为创建的时候尖括号泛型已经说了是字符串，添加进去的元素就必须都是字符串才行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.day07.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ArrayList当中的常用方法有：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。</span></span><br><span class="line"><span class="comment">备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。</span></span><br><span class="line"><span class="comment">但是对于其他集合（今后学习）来说，add添加动作不一定成功。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03ArrayListMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(list); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向集合中添加元素：add</span></span><br><span class="line">        <span class="keyword">boolean</span> success = list.add(<span class="string">"柳岩"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [柳岩]</span></span><br><span class="line">        System.out.println(<span class="string">"添加的动作是否成功："</span> + success); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"高圆圆"</span>);</span><br><span class="line">        list.add(<span class="string">"赵又廷"</span>);</span><br><span class="line">        list.add(<span class="string">"李小璐"</span>);</span><br><span class="line">        list.add(<span class="string">"贾乃亮"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [柳岩, 高圆圆, 赵又廷, 李小璐, 贾乃亮]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中获取元素：get。索引值从0开始</span></span><br><span class="line">        String name = list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"第2号索引位置："</span> + name); <span class="comment">// 赵又廷</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中删除元素：remove。索引值从0开始。</span></span><br><span class="line">        String whoRemoved = list.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"被删除的人是："</span> + whoRemoved); <span class="comment">// 李小璐</span></span><br><span class="line">        System.out.println(list); <span class="comment">// [柳岩, 高圆圆, 赵又廷, 贾乃亮]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取集合的长度尺寸，也就是其中元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        System.out.println(<span class="string">"集合的长度是："</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.day07.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">基本类型    包装类（引用类型，包装类都位于java.lang包下）</span></span><br><span class="line"><span class="comment">byte        Byte</span></span><br><span class="line"><span class="comment">short       Short</span></span><br><span class="line"><span class="comment">int         Integer     【特殊】</span></span><br><span class="line"><span class="comment">long        Long</span></span><br><span class="line"><span class="comment">float       Float</span></span><br><span class="line"><span class="comment">double      Double</span></span><br><span class="line"><span class="comment">char        Character   【特殊】</span></span><br><span class="line"><span class="comment">boolean     Boolean</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">从JDK 1.5+开始，支持自动装箱、自动拆箱。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">自动装箱：基本类型 --&gt; 包装类型</span></span><br><span class="line"><span class="comment">自动拆箱：包装类型 --&gt; 基本类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05ArrayListBasic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; listA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 错误写法！泛型只能是引用类型，不能是基本类型</span></span><br><span class="line"><span class="comment">//        ArrayList&lt;int&gt; listB = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; listC = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        listC.add(<span class="number">100</span>);</span><br><span class="line">        listC.add(<span class="number">200</span>);</span><br><span class="line">        System.out.println(listC); <span class="comment">// [100, 200]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = listC.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"第1号元素是："</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="String初始化"><a href="#String初始化" class="headerlink" title="String初始化"></a>String初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.lang.String类代表字符串。</span></span><br><span class="line"><span class="comment">API当中说：Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。</span></span><br><span class="line"><span class="comment">其实就是说：程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符串的特点：</span></span><br><span class="line"><span class="comment">1. 字符串的内容永不可变。【重点】</span></span><br><span class="line"><span class="comment">2. 正是因为字符串不可改变，所以字符串是可以共享使用的。</span></span><br><span class="line"><span class="comment">3. 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">创建字符串的常见3+1种方式。</span></span><br><span class="line"><span class="comment">三种构造方法：</span></span><br><span class="line"><span class="comment">public String()：创建一个空白字符串，不含有任何内容。</span></span><br><span class="line"><span class="comment">public String(char[] array)：根据字符数组的内容，来创建对应的字符串。</span></span><br><span class="line"><span class="comment">public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。</span></span><br><span class="line"><span class="comment">一种直接创建：</span></span><br><span class="line"><span class="comment">String str = "Hello"; // 右边直接用双引号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：直接写上双引号，就是字符串对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01String</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用空参构造</span></span><br><span class="line">        String str1 = <span class="keyword">new</span> String(); <span class="comment">// 小括号留空，说明字符串什么内容都没有。</span></span><br><span class="line">        System.out.println(<span class="string">"第1个字符串："</span> + str1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据字符数组创建字符串</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span> &#125;;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(charArray);</span><br><span class="line">        System.out.println(<span class="string">"第2个字符串："</span> + str2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据字节数组创建字符串</span></span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = &#123; <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span> &#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(byteArray);</span><br><span class="line">        System.out.println(<span class="string">"第3个字符串："</span> + str3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接创建</span></span><br><span class="line">        String str4 = <span class="string">"Hello"</span>;</span><br><span class="line">        System.out.println(<span class="string">"第4个字符串："</span> + str4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于基本类型来说，==是进行数值的比较。</span></span><br><span class="line"><span class="comment">对于引用类型来说，==是进行【地址值】的比较。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str1 == str3); <span class="comment">// false</span></span><br><span class="line">        System.out.println(str2 == str3); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述比较的原因</p>
<p><img src="/blog/imgs/java/changliangchi.png" alt></p>
<h4 id="euqals的使用"><a href="#euqals的使用" class="headerlink" title="euqals的使用"></a><code>euqals</code>的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">==是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两个方法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1. 任何对象都能用Object进行接收。</span></span><br><span class="line"><span class="comment">2. equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。</span></span><br><span class="line"><span class="comment">3. 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。</span></span><br><span class="line"><span class="comment">推荐："abc".equals(str)    不推荐：str.equals("abc")</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01StringEquals</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String str2 = <span class="string">"Hello"</span>;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2.equals(str3)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str3.equals(<span class="string">"Hello"</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>.equals(str1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        String str4 = <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(str1.equals(str4)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"================="</span>);</span><br><span class="line"></span><br><span class="line">        String str5 = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"abc"</span>.equals(str5)); <span class="comment">// 推荐：false</span></span><br><span class="line"><span class="comment">//        System.out.println(str5.equals("abc")); // 不推荐：报错，空指针异常NullPointerException</span></span><br><span class="line">        System.out.println(<span class="string">"================="</span>);</span><br><span class="line"></span><br><span class="line">        String strA = <span class="string">"Java"</span>;</span><br><span class="line">        String strB = <span class="string">"java"</span>;</span><br><span class="line">        System.out.println(strA.equals(strB)); <span class="comment">// false，严格区分大小写</span></span><br><span class="line">        System.out.println(strA.equalsIgnoreCase(strB)); <span class="comment">// true，忽略大小写</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，只有英文字母区分大小写，其他都不区分大小写</span></span><br><span class="line">        System.out.println(<span class="string">"abc一123"</span>.equalsIgnoreCase(<span class="string">"abc壹123"</span>)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String常用API"><a href="#String常用API" class="headerlink" title="String常用API"></a>String常用API</h2><h4 id="获取相关"><a href="#获取相关" class="headerlink" title="获取相关"></a>获取相关</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">String当中与获取相关的常用方法有：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int length()：获取字符串当中含有的字符个数，拿到字符串长度。</span></span><br><span class="line"><span class="comment">public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。</span></span><br><span class="line"><span class="comment">public char charAt(int index)：获取指定索引位置的单个字符。（索引从0开始。）</span></span><br><span class="line"><span class="comment">public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringGet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="string">"asdasfeutrvauevbueyvb"</span>.length();</span><br><span class="line">        System.out.println(<span class="string">"字符串的长度是："</span> + length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接字符串</span></span><br><span class="line">        String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String str2 = <span class="string">"World"</span>;</span><br><span class="line">        String str3 = str1.concat(str2);</span><br><span class="line">        System.out.println(str1); <span class="comment">// Hello，原封不动</span></span><br><span class="line">        System.out.println(str2); <span class="comment">// World，原封不动</span></span><br><span class="line">        System.out.println(str3); <span class="comment">// HelloWorld，新的字符串</span></span><br><span class="line">        System.out.println(<span class="string">"=============="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定索引位置的单个字符</span></span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">"Hello"</span>.charAt(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"在1号索引位置的字符是："</span> + ch);</span><br><span class="line">        System.out.println(<span class="string">"=============="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找参数字符串在本来字符串当中出现的第一次索引位置</span></span><br><span class="line">        <span class="comment">// 如果根本没有，返回-1值</span></span><br><span class="line">        String original = <span class="string">"HelloWorldHelloWorld"</span>;</span><br><span class="line">        <span class="keyword">int</span> index = original.indexOf(<span class="string">"llo"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第一次索引值是："</span> + index); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>.indexOf(<span class="string">"abc"</span>)); <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo02;</span><br></pre></td></tr></table></figure>

<h4 id="字符串提取以及替换"><a href="#字符串提取以及替换" class="headerlink" title="字符串提取以及替换"></a>字符串提取以及替换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符串的截取方法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。</span></span><br><span class="line"><span class="comment">public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。</span></span><br><span class="line"><span class="comment">备注：[begin,end)，包含左边，不包含右边。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Substring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"HelloWorld"</span>;</span><br><span class="line">        String str2 = str1.substring(<span class="number">5</span>);</span><br><span class="line">        System.out.println(str1); <span class="comment">// HelloWorld，原封不动</span></span><br><span class="line">        System.out.println(str2); <span class="comment">// World，新字符串</span></span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line"></span><br><span class="line">        String str3 = str1.substring(<span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(str3); <span class="comment">// oWo</span></span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这种写法，字符串的内容仍然是没有改变的</span></span><br><span class="line">        <span class="comment">// 下面有两个字符串："Hello"，"Java"</span></span><br><span class="line">        <span class="comment">// strA当中保存的是地址值。</span></span><br><span class="line">        <span class="comment">// 本来地址值是Hello的0x666，</span></span><br><span class="line">        <span class="comment">// 后来地址值变成了Java的0x999</span></span><br><span class="line">        String strA = <span class="string">"Hello"</span>;</span><br><span class="line">        System.out.println(strA); <span class="comment">// Hello</span></span><br><span class="line">        strA = <span class="string">"Java"</span>;</span><br><span class="line">        System.out.println(strA); <span class="comment">// Java</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">String当中与转换相关的常用方法有：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。</span></span><br><span class="line"><span class="comment">public byte[] getBytes()：获得当前字符串底层的字节数组。</span></span><br><span class="line"><span class="comment">public String replace(CharSequence oldString, CharSequence newString)：</span></span><br><span class="line"><span class="comment">将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。</span></span><br><span class="line"><span class="comment">备注：CharSequence意思就是说可以接受字符串类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04StringConvert</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转换成为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="string">"Hello"</span>.toCharArray();</span><br><span class="line">        System.out.println(chars[<span class="number">0</span>]); <span class="comment">// H</span></span><br><span class="line">        System.out.println(chars.length); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(<span class="string">"=============="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换成为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">"abc"</span>.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            System.out.println(bytes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"=============="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串的内容替换</span></span><br><span class="line">        String str1 = <span class="string">"How do you do?"</span>;</span><br><span class="line">        String str2 = str1.replace(<span class="string">"o"</span>, <span class="string">"*"</span>);</span><br><span class="line">        System.out.println(str1); <span class="comment">// How do you do?</span></span><br><span class="line">        System.out.println(str2); <span class="comment">// H*w d* y*u d*?</span></span><br><span class="line">        System.out.println(<span class="string">"=============="</span>);</span><br><span class="line"></span><br><span class="line">        String lang1 = <span class="string">"会不会玩儿呀！你大爷的！你大爷的！你大爷的！！！"</span>;</span><br><span class="line">        String lang2 = lang1.replace(<span class="string">"你大爷的"</span>, <span class="string">"****"</span>);</span><br><span class="line">        System.out.println(lang2); <span class="comment">// 会不会玩儿呀！****！****！****！！！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分割字符串的方法：</span></span><br><span class="line"><span class="comment">public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">split方法的参数其实是一个“正则表达式”，今后学习。</span></span><br><span class="line"><span class="comment">今天要注意：如果按照英文句点“.”进行切分，必须写"\\."（两个反斜杠）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05StringSplit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"aaa,bbb,ccc"</span>;</span><br><span class="line">        String[] array1 = str1.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">            System.out.println(array1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line"></span><br><span class="line">        String str2 = <span class="string">"aaa bbb ccc"</span>;</span><br><span class="line">        String[] array2 = str2.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.length; i++) &#123;</span><br><span class="line">            System.out.println(array2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line"></span><br><span class="line">        String str3 = <span class="string">"XXX.YYY.ZZZ"</span>;</span><br><span class="line">        String[] array3 = str3.split(<span class="string">"\\."</span>);</span><br><span class="line">        System.out.println(array3.length); <span class="comment">// 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array3.length; i++) &#123;</span><br><span class="line">            System.out.println(array3[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Static关键字的使用"><a href="#Static关键字的使用" class="headerlink" title="Static关键字的使用"></a>Static关键字的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。</span></span><br><span class="line"><span class="comment">如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。</span></span><br><span class="line"><span class="comment">静态变量：类名称.静态变量</span></span><br><span class="line"><span class="comment">静态方法：类名称.静态方法()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1. 静态不能直接访问非静态。</span></span><br><span class="line"><span class="comment">原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。</span></span><br><span class="line"><span class="comment">“先人不知道后人，但是后人知道先人。”</span></span><br><span class="line"><span class="comment">2. 静态方法当中不能用this。</span></span><br><span class="line"><span class="comment">原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StaticMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass obj = <span class="keyword">new</span> MyClass(); <span class="comment">// 首先创建对象</span></span><br><span class="line">        <span class="comment">// 然后才能使用没有static关键字的内容</span></span><br><span class="line">        obj.method();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。</span></span><br><span class="line">        obj.methodStatic(); <span class="comment">// 正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”</span></span><br><span class="line">        MyClass.methodStatic(); <span class="comment">// 正确，推荐</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于本来当中的静态方法，可以省略类名称</span></span><br><span class="line">        myMethod();</span><br><span class="line">        Demo02StaticMethod.myMethod(); <span class="comment">// 完全等效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"自己的方法！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h6><p><img src="/blog/imgs/java/static.png" alt></p>
<h4 id="静态代码块的使用"><a href="#静态代码块的使用" class="headerlink" title="静态代码块的使用"></a>静态代码块的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态代码块的格式是：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public class 类名称 &#123;</span></span><br><span class="line"><span class="comment">    static &#123;</span></span><br><span class="line"><span class="comment">        // 静态代码块的内容</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特点：当第一次用到本类时，静态代码块执行唯一的一次。</span></span><br><span class="line"><span class="comment">静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">静态代码块的典型用途：</span></span><br><span class="line"><span class="comment">用来一次性地对静态成员变量进行赋值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Static</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person one = <span class="keyword">new</span> Person();</span><br><span class="line">        Person two = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Arrays的两个静态方法"><a href="#Arrays的两个静态方法" class="headerlink" title="Arrays的两个静态方法"></a>Arrays的两个静态方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3...]）</span></span><br><span class="line"><span class="comment">public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">备注：</span></span><br><span class="line"><span class="comment">1. 如果是数值，sort默认按照升序从小到大</span></span><br><span class="line"><span class="comment">2. 如果是字符串，sort默认按照字母升序</span></span><br><span class="line"><span class="comment">3. 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（今后学习）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Arrays</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] intArray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="comment">// 将int[]数组按照默认格式变成字符串</span></span><br><span class="line">        String intStr = Arrays.toString(intArray);</span><br><span class="line">        System.out.println(intStr); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] array1 = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        Arrays.sort(array1);</span><br><span class="line">        System.out.println(Arrays.toString(array1)); <span class="comment">// [1, 2, 3, 6, 10]</span></span><br><span class="line"></span><br><span class="line">        String[] array2 = &#123;<span class="string">"bbb"</span>, <span class="string">"aaa"</span>, <span class="string">"ccc"</span>&#125;;</span><br><span class="line">        Arrays.sort(array2);</span><br><span class="line">        System.out.println(Arrays.toString(array2)); <span class="comment">// [aaa, bbb, ccc]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Math的常用静态方法"><a href="#Math的常用静态方法" class="headerlink" title="Math的常用静态方法"></a>Math的常用静态方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day08.demo04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static double abs(double num)：获取绝对值。有多种重载。</span></span><br><span class="line"><span class="comment">public static double ceil(double num)：向上取整。</span></span><br><span class="line"><span class="comment">public static double floor(double num)：向下取整。</span></span><br><span class="line"><span class="comment">public static long round(double num)：四舍五入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Math.PI代表近似的圆周率常量（double）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取绝对值</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">3.14</span>)); <span class="comment">// 3.14</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">2.5</span>)); <span class="comment">// 2.5</span></span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上取整</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.9</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.1</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.0</span>)); <span class="comment">// 3.0</span></span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下取整，抹零</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">30.1</span>)); <span class="comment">// 30.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">30.9</span>)); <span class="comment">// 30.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">31.0</span>)); <span class="comment">// 31.0</span></span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Math.round(<span class="number">20.4</span>)); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">10.5</span>)); <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learn java</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始学java-1</title>
    <url>/2019/11/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6java-1/</url>
    <content><![CDATA[<h2 id="命令提示符（cmd-command-）"><a href="#命令提示符（cmd-command-）" class="headerlink" title="命令提示符（cmd(command)）"></a>命令提示符（cmd(command)）</h2><p>启动：win+r</p><p>切换盘符：盘符名称：</p><p>进入文件夹：cd 文件夹名称</p><a id="more"></a>


<p>进入多级文件夹：cd 文件夹1\文件夹2...</p>
<p>后退到根目录：cd \ </p>
<h2 id><a href="#" class="headerlink" title></a></h2><p><strong>JVM</strong>（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 <strong>跨平台</strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系 统上，这个特性称为<strong>Java**</strong>语言的跨平台特性**。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM 运行在操作系统上。 查看文件夹文件列表：dir</p>
<p>清屏：cls</p>
<p>退出：exit</p>
<hr>
<h2 id="Java虚拟机–JVM"><a href="#Java虚拟机–JVM" class="headerlink" title="Java虚拟机–JVM"></a>Java虚拟机–JVM</h2><ul>
<li><strong>JVM</strong>（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 </li>
<li><strong>跨平台</strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系 统上，这个特性称为<strong>Java</strong>语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM 运行在操作系统上。 </li>
</ul>
<p><img src="/blog/imgs/java/jvm.png" alt></p>
<p>如图所示，Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。</p>
<hr>
<h2 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h2><p><strong>JRE</strong> (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。 </p>
<p><strong>JDK</strong> (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 我们想要运行一个已有的Java程序，那么只需安装 JRE 即可。 我们想要开发一个全新的Java程序，那么必须安装 JDK 。 </p>
<p><img src="/blog/imgs/java/jdk2.png" alt></p>
<p><img src="/blog/imgs/java/jdk.png" alt></p>
<p>小贴士： 三者关系： JDK &gt; JRE &gt; JVM </p>
<hr>
<h2 id="环境变量的设置"><a href="#环境变量的设置" class="headerlink" title="环境变量的设置"></a>环境变量的设置</h2><p><img src="/blog/imgs/java/peizhi.png" alt></p>
<p>在系统变量中这样设置即可。</p>
<hr>
<h2 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h2><p>javac编译.java文件生成.class文件</p>
<p>java执行.class文件，但是命令不需要.class后缀</p>
<p><img src="/blog/imgs/java/compile.png" alt></p>
<hr>
<h2 id="常量类型"><a href="#常量类型" class="headerlink" title="常量类型"></a>常量类型</h2><p><img src="/blog/imgs/java/changliang.png" alt></p>
<p><code>&quot;&quot;</code>能输出（空字符串能输出），<code>&#39;&#39;</code>不能输出（不能为空字符，加一个空格则正确）。</p>
<hr>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型<br>    整数型    byte short int long<br>    浮点型    float double<br>    字符型    char<br>    布尔型    boolean</p>
<p>引用数据类型（今后学习）<br>    字符串、数组、类、接口、Lambda</p>
<p>注意事项：</p>
<ol>
<li><p>字符串不是基本类型，而是引用类型。</p>
</li>
<li><p>浮点型可能只是一个近似值，并非精确的值。</p>
</li>
<li><p>数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。</p>
</li>
<li><p>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。<br>如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。</p>
</li>
</ol>
<p>   <strong>四类八种基本数据类型：</strong></p>
<p><img src="/blog/imgs/java/shujuleixing.png" alt></p>
<h5 id="注意变量的作用域"><a href="#注意变量的作用域" class="headerlink" title="注意变量的作用域"></a>注意变量的作用域</h5><p><img src="/blog/imgs/java/zuoyongyu.png" alt></p>
<p>可在{}外定义相同名字的变量</p>
<p><strong>有时候if语句中定义的变量，{}外面不能使用。</strong></p>
<hr>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h4 id="自动类型转换（隐式）"><a href="#自动类型转换（隐式）" class="headerlink" title="自动类型转换（隐式）"></a>自动类型转换（隐式）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当数据类型不一样时，将会发生数据类型转换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">自动类型转换（隐式）</span></span><br><span class="line"><span class="comment">	1. 特点：代码不需要进行特殊处理，自动完成。</span></span><br><span class="line"><span class="comment">	2. 规则：数据范围从小到大。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">强制类型转换（显式）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01DataType</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="number">1024</span>); <span class="comment">// 这就是一个整数，默认就是int类型</span></span><br><span class="line">		System.out.println(<span class="number">3.14</span>); <span class="comment">// 这就是一个浮点数，默认就是double类型</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 左边是long类型，右边是默认的int类型，左右不一样</span></span><br><span class="line">		<span class="comment">// 一个等号代表赋值，将右侧的int常量，交给左侧的long变量进行存储</span></span><br><span class="line">		<span class="comment">// int --&gt; long，符合了数据范围从小到大的要求</span></span><br><span class="line">		<span class="comment">// 这一行代码发生了自动类型转换。</span></span><br><span class="line">		<span class="keyword">long</span> num1 = <span class="number">100</span>;</span><br><span class="line">		System.out.println(num1); <span class="comment">// 100</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 左边是double类型，右边是float类型，左右不一样</span></span><br><span class="line">		<span class="comment">// float --&gt; double，符合从小到大的规则</span></span><br><span class="line">		<span class="comment">// 也发生了自动类型转换</span></span><br><span class="line">		<span class="keyword">double</span> num2 = <span class="number">2.5F</span>;</span><br><span class="line">		System.out.println(num2); <span class="comment">// 2.5</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 左边是float类型，右边是long类型，左右不一样</span></span><br><span class="line">		<span class="comment">// long --&gt; float，范围是float更大一些，符合从小到大的规则</span></span><br><span class="line">		<span class="comment">// 也发生了自动类型转换</span></span><br><span class="line">		<span class="keyword">float</span> num3 = <span class="number">30L</span>;</span><br><span class="line">		System.out.println(num3); <span class="comment">// 30.0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，</span></span><br><span class="line"><span class="comment">那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 如果没有超过左侧的范围，编译器补上强转。</span></span><br><span class="line"><span class="comment">2. 如果右侧超过了左侧范围，那么直接编译器报错。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12Notice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 右侧确实是一个int数字，但是没有超过左侧的范围，就是正确的。</span></span><br><span class="line">		<span class="comment">// int --&gt; byte，不是自动类型转换</span></span><br><span class="line">		<span class="keyword">byte</span> num1 = <span class="comment">/*(byte)*/</span> <span class="number">30</span>; <span class="comment">// 右侧没有超过左侧的范围</span></span><br><span class="line">		System.out.println(num1); <span class="comment">// 30</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// byte num2 = 128; // 右侧超过了左侧的范围</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// int --&gt; char，没有超过范围</span></span><br><span class="line">		<span class="comment">// 编译器将会自动补上一个隐含的(char)</span></span><br><span class="line">		<span class="keyword">char</span> zifu = <span class="comment">/*(char)*/</span> <span class="number">65</span>;</span><br><span class="line">		System.out.println(zifu); <span class="comment">// A</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，</span></span><br><span class="line"><span class="comment">那么编译器javac将会直接将若干个常量表达式计算得到结果。</span></span><br><span class="line"><span class="comment">short result = 5 + 8; // 等号右边全都是常量，没有任何变量参与运算</span></span><br><span class="line"><span class="comment">编译之后，得到的.class字节码文件当中相当于【直接就是】：</span></span><br><span class="line"><span class="comment">short result = 13;</span></span><br><span class="line"><span class="comment">右侧的常量结果数值，没有超过左侧范围，所以正确。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这称为“编译器的常量优化”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo13Notice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">short</span> num1 = <span class="number">10</span>; <span class="comment">// 正确写法，右侧没有超过左侧的范围，</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">short</span> a = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">short</span> b = <span class="number">8</span>;</span><br><span class="line">		<span class="comment">// short + short --&gt; int + int --&gt; int</span></span><br><span class="line">		<span class="comment">// short result = a + b; // 错误写法！左侧需要是int类型</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 右侧不用变量，而是采用常量，而且只有两个常量，没有别人</span></span><br><span class="line">		<span class="keyword">short</span> result = <span class="number">5</span> + <span class="number">8</span>;</span><br><span class="line">		System.out.println(result);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">short</span> result2 = <span class="number">5</span> + a + <span class="number">8</span>; <span class="comment">// 18</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强制类型转换（显式）"><a href="#强制类型转换（显式）" class="headerlink" title="强制类型转换（显式）"></a>强制类型转换（显式）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">强制类型转换</span></span><br><span class="line"><span class="comment">	1. 特点：代码需要进行特殊的格式处理，不能自动完成。</span></span><br><span class="line"><span class="comment">	2. 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">	1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。</span></span><br><span class="line"><span class="comment">	2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”.</span></span><br><span class="line"><span class="comment">	3. byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。</span></span><br><span class="line"><span class="comment">	4. boolean类型不能发生数据类型转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02DataType</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 左边是int类型，右边是long类型，不一样</span></span><br><span class="line">		<span class="comment">// long --&gt; int，不是从小到大</span></span><br><span class="line">		<span class="comment">// 不能发生自动类型转换！</span></span><br><span class="line">		<span class="comment">// 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</span></span><br><span class="line">		<span class="keyword">int</span> num = (<span class="keyword">int</span>) <span class="number">100L</span>;</span><br><span class="line">		System.out.println(num);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// long强制转换成为int类型</span></span><br><span class="line">		<span class="keyword">int</span> num2 = (<span class="keyword">int</span>) <span class="number">6000000000L</span>;</span><br><span class="line">		System.out.println(num2); <span class="comment">// 1705032704</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// double --&gt; int，强制类型转换</span></span><br><span class="line">		<span class="keyword">int</span> num3 = (<span class="keyword">int</span>) <span class="number">3.99</span>;</span><br><span class="line">		System.out.println(num3); <span class="comment">// 3，这并不是四舍五入，所有的小数位都会被舍弃掉</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> zifu1 = <span class="string">'A'</span>; <span class="comment">// 这是一个字符型变量，里面是大写字母A</span></span><br><span class="line">		System.out.println(zifu1 + <span class="number">1</span>); <span class="comment">// 66，也就是大写字母A被当做65进行处理</span></span><br><span class="line">		<span class="comment">// 计算机的底层会用一个数字（二进制）来代表字符A，就是65</span></span><br><span class="line">		<span class="comment">// 一旦char类型进行了数学运算，那么字符就会按照一定的规则翻译成为一个数字</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">byte</span> num4 = <span class="number">40</span>; <span class="comment">// 注意！右侧的数值大小不能超过左侧的类型范围</span></span><br><span class="line">		<span class="keyword">byte</span> num5 = <span class="number">50</span>;</span><br><span class="line">		<span class="comment">// byte + byte --&gt; int + int --&gt; int</span></span><br><span class="line">		<span class="keyword">int</span> result1 = num4 + num5;</span><br><span class="line">		System.out.println(result1); <span class="comment">// 90</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">short</span> num6 = <span class="number">60</span>;</span><br><span class="line">		<span class="comment">// byte + short --&gt; int + int --&gt; int</span></span><br><span class="line">		<span class="comment">// int强制转换为short：注意必须保证逻辑上真实大小本来就没有超过short范围，否则会发生数据溢出</span></span><br><span class="line">		<span class="keyword">short</span> result2 = (<span class="keyword">short</span>) (num4 + num6);</span><br><span class="line">		System.out.println(result2); <span class="comment">// 100</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数字和字符的对照关系表（编码表）：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ASCII码表：American Standard Code for Information Interchange，美国信息交换标准代码。</span></span><br><span class="line"><span class="comment">Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">48 - '0'</span></span><br><span class="line"><span class="comment">65 - 'A'</span></span><br><span class="line"><span class="comment">97 - 'a'</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03DataTypeChar</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span> zifu1 = <span class="string">'1'</span>;</span><br><span class="line">		System.out.println(zifu1 + <span class="number">0</span>); <span class="comment">// 49</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> zifu2 = <span class="string">'A'</span>; <span class="comment">// 其实底层保存的是65数字</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> zifu3 = <span class="string">'c'</span>;</span><br><span class="line">		<span class="comment">// 左侧是int类型，右边是char类型，</span></span><br><span class="line">		<span class="comment">// char --&gt; int，确实是从小到大</span></span><br><span class="line">		<span class="comment">// 发生了自动类型转换</span></span><br><span class="line">		<span class="keyword">int</span> num = zifu3;</span><br><span class="line">		System.out.println(num); <span class="comment">// 99</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> zifu4 = <span class="string">'中'</span>; <span class="comment">// 正确写法</span></span><br><span class="line">		System.out.println(zifu4 + <span class="number">0</span>); <span class="comment">// 20013</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加法的用法"><a href="#加法的用法" class="headerlink" title="加法的用法"></a>加法的用法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">四则运算当中的加号“+”有常见的三种用法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 对于数值来说，那就是加法。</span></span><br><span class="line"><span class="comment">2. 对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算。</span></span><br><span class="line"><span class="comment">char类型字符，和int类型数字，之间的对照关系表：ASCII、Unicode</span></span><br><span class="line"><span class="comment">3. 对于字符串String（首字母大写，并不是关键字）来说，加号代表字符串连接操作。</span></span><br><span class="line"><span class="comment">任何数据类型和字符串进行连接的时候，结果都会变成字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Plus</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 字符串类型的变量基本使用</span></span><br><span class="line">		<span class="comment">// 数据类型 变量名称 = 数据值;</span></span><br><span class="line">		String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">		System.out.println(str1); <span class="comment">// Hello</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"Hello"</span> + <span class="string">"World"</span>); <span class="comment">// HelloWorld</span></span><br><span class="line">		</span><br><span class="line">		String str2 = <span class="string">"Java"</span>;</span><br><span class="line">		<span class="comment">// String + int --&gt; String</span></span><br><span class="line">		System.out.println(str2 + <span class="number">20</span>); <span class="comment">// Java20</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 优先级问题</span></span><br><span class="line">		<span class="comment">// String + int + int</span></span><br><span class="line">		<span class="comment">// String		+ int</span></span><br><span class="line">		<span class="comment">// String</span></span><br><span class="line">		System.out.println(str2 + <span class="number">20</span> + <span class="number">30</span>); <span class="comment">// Java2030</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(str2 + (<span class="number">20</span> + <span class="number">30</span>)); <span class="comment">// Java50</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch的一些注意事项"><a href="#switch的一些注意事项" class="headerlink" title="switch的一些注意事项"></a>switch的一些注意事项</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">switch语句使用的注意事项：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 多个case后面的数值不可以重复。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. switch后面小括号当中只能是下列数据类型：</span></span><br><span class="line"><span class="comment">基本数据类型：byte/short/char/int</span></span><br><span class="line"><span class="comment">引用数据类型：String字符串、enum枚举</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。</span></span><br><span class="line"><span class="comment">“匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者整体结束为止。”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08SwitchNotice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">switch</span> (num) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				System.out.println(<span class="string">"你好"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				System.out.println(<span class="string">"我好"</span>);</span><br><span class="line">				<span class="comment">// break;</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				System.out.println(<span class="string">"大家好"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				System.out.println(<span class="string">"他好，我也好。"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="comment">// switch</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learn java</category>
      </categories>
  </entry>
  <entry>
    <title>algorithm-7</title>
    <url>/2019/11/19/algorithm-7/</url>
    <content><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p> 有许多问题，当需要找出它的解集或者要求在某些约束条件下的最优解时，往往可以采用回溯法。</p><p>回溯法的基本做法是<em>搜索</em>，它是一种可以<em>避免不必要搜索的穷举式搜索法</em>。</p><a id="more"></a>

<p>回溯法适合求解一些<em>组合数较大</em>的问题。</p>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li><p>回溯法在问题的解空间树中，按深度优先策略，从根节点出发搜索解空间树。</p>
</li>
<li><p>算法搜索至解空间树的任意一点时，先判断该节点是否包含问题的解。</p>
<ul>
<li>如果肯定不包含，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯。</li>
</ul>
</li>
<li><p>否则进入该子树，继续按深度优先策略搜索</p>
</li>
</ul>
<h4 id="生成问题状态的说明"><a href="#生成问题状态的说明" class="headerlink" title="生成问题状态的说明"></a>生成问题状态的说明</h4><ul>
<li>扩展节点：一个正在产生儿子的节点成为扩展节点。</li>
<li>活节点：一个自身已生成但其儿子还没有全部生成的节点称作活节点。</li>
<li>死节点：一个所有儿子已经产生的节点成为死节点。</li>
</ul>
<h4 id="生成问题状态的基本方法"><a href="#生成问题状态的基本方法" class="headerlink" title="生成问题状态的基本方法"></a>生成问题状态的基本方法</h4><p>回溯法：为了避免生成那些不可能产生最优解的问题状态，要不断得利用限界函数（bounding function）来“处死”那些实际上不可能产生所需解的活节点，从而减少问题的计算量。<em>具有限界函数的深度优先生成法</em>称为回溯法。</p>
<h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol>
<li>针对所给问题，定义问题的解空间。</li>
<li>确定易于搜索的解空间结构。</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h6 id="常用剪枝函数"><a href="#常用剪枝函数" class="headerlink" title="常用剪枝函数"></a>常用剪枝函数</h6><ul>
<li>用约束函数在扩展节点处剪去不满足约束的子树。</li>
<li>用限界函数剪去得不到最优解的子树。</li>
</ul>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p>在搜索至树上任意一点时，先判断该节点对应部分解是否满足约束条件，或是否超过目标函数的界。</p>
<ul>
<li>判断该节点是否包含问题的（最优）解<ul>
<li>不包含，则跳过对以该节点为根的子树的搜索，剪枝（pruning）。 </li>
<li>包含，则进入以该节点为根的子树，继续按深度优先搜索。</li>
</ul>
</li>
</ul>
<h4 id="回溯法求解时常见的两类解空间树"><a href="#回溯法求解时常见的两类解空间树" class="headerlink" title="回溯法求解时常见的两类解空间树"></a>回溯法求解时常见的两类解空间树</h4><h5 id="子集树："><a href="#子集树：" class="headerlink" title="子集树："></a>子集树：</h5><p>类似于01背包的，每件物品可取可不取的树。P115</p>
<h5 id="排列树："><a href="#排列树：" class="headerlink" title="排列树："></a>排列树：</h5><p>类似于tsp问题的，总数为n！的树。P116</p>
<p>​                       </p>
<h1 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h1><p>类似于回溯法，是在问题的解空间树上搜索问题解的答案。</p>
<p>不同点：</p>
<ul>
<li>求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有借，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出某种意义下的最优解。</li>
<li>搜索方式的不同：回溯法以<strong><em>深度优先</em></strong>的方式搜索解空间树，而分支限界法以<strong>广度优先</strong>或以<strong>最小耗费优先</strong>的方式搜索解空间树。</li>
</ul>
<h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>分支限界法常以广度优先或以最小耗费（最大收益）优先的方式搜索问题的解空间树。</p>
<ul>
<li>在分支限界法中，每一个活节点只有一次机会成为扩展节点。活节点一旦成为扩展节点，就一次性产生其所有儿子节点。在这些儿子节点中，导致不可行解或导致非最优解的儿子节点被舍弃，其余儿子节点被加入活结点表中。</li>
<li>此后，从活节点表中取下一节点成为当前扩展节点，并重复上述节点扩展过程。这个郭晨肝移植持续到找到所需的解或者活结点表为空为止。</li>
</ul>
<h4 id="常见的两种分支限界法"><a href="#常见的两种分支限界法" class="headerlink" title="常见的两种分支限界法"></a>常见的两种分支限界法</h4><h5 id="队列式（FIFO）分支限界法"><a href="#队列式（FIFO）分支限界法" class="headerlink" title="队列式（FIFO）分支限界法"></a>队列式（FIFO）分支限界法</h5><p>按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。</p>
<h5 id="优先队列式分支限界法"><a href="#优先队列式分支限界法" class="headerlink" title="优先队列式分支限界法"></a>优先队列式分支限界法</h5><ul>
<li>按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</li>
<li>应用优先队列式分支限界法求解具体问题时，应该根据具体问题的特点确定选用最大优先队列活着最小优先队列表示解空间的活结点表。</li>
</ul>
]]></content>
      <categories>
        <category>learn algorithm</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
        <tag>分支限界法</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-6</title>
    <url>/2019/11/19/algorithm-6/</url>
    <content><![CDATA[<h1 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h1><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><h5 id="随机序列"><a href="#随机序列" class="headerlink" title="随机序列"></a>随机序列</h5><ul>
<li>概率相等（均匀随机）</li>
<li>不可预测</li>
<li>不可重现</li>
</ul><ul>
<li>目前的计算机中，无法产生真正的随机数，因此在随机算法中使用的随机数 都是一定程度上随机的，即伪随机数。</li>
<li>产生伪随机数的方法：线性同余法……</li>
</ul><a id="more"></a>

<h4 id="确定性算法"><a href="#确定性算法" class="headerlink" title="确定性算法"></a>确定性算法</h4><p>输入确定，则对这个特定输入的每次运行过程是可重复的，运行结果是一样的。</p>
<p>比如，对于输入&lt;6,4,5,8,9,3&gt;，正确的插入排序算法对于这个输入，每次的运行过程是一样的，运行结果也是一样的。</p>
<h4 id="随机算法的基本思想"><a href="#随机算法的基本思想" class="headerlink" title="随机算法的基本思想"></a>随机算法的基本思想</h4><ul>
<li><p>Randomized Algorithms(随机算法)</p>
</li>
<li><p>Probabilistic Algorithms概率算法）</p>
</li>
<li><p>引入了随机因素</p>
</li>
<li><p>在随机算法中</p>
<ul>
<li><p>不要求算法对于所有可能的输入均正确计算</p>
<ul>
<li>只要求出现错误的可能性晓得可以忽略的程度。</li>
</ul>
</li>
</ul>
</li>
<li><p>另外也不要求对同一输入，算法每次执行时给出相同的结果。</p>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>有不少问题，目前只有效率很差的确定性求解算法，但用随机算法去求解，可以很快的获得相当可信的结果。</p>
<h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><ul>
<li>随机算法在分布式计算、通信、信息检索、计算几何、密码学等血多领域都有着广泛的应用。</li>
<li>最著名的是在公开密钥体系、RSA算法方面的应用。</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>通常可以分为两类</p>
<ul>
<li>Las Vegas算法</li>
<li>Monte Carlo算法</li>
</ul>
<h4 id="Las-Vegas算法"><a href="#Las-Vegas算法" class="headerlink" title="Las Vegas算法"></a>Las Vegas算法</h4><ul>
<li>在少数应用中，可能出现求不出解的情况。</li>
<li>但一旦找到一个解，这个解一定是正确的。</li>
<li>再求不出来解时，需要再次调用算法进行计算，直到获得解为止。</li>
<li>对于此类算法，主要是分析算法的时间复杂度的期望值，以及调用一次产生失败（求不出解）的概率。</li>
</ul>
<h5 id="举例：找第k小元素的随机算法"><a href="#举例：找第k小元素的随机算法" class="headerlink" title="举例：找第k小元素的随机算法"></a>举例：找第k小元素的随机算法</h5><h4 id="Monte-Carlo算法"><a href="#Monte-Carlo算法" class="headerlink" title="Monte Carlo算法"></a>Monte Carlo算法</h4><ul>
<li>通常不能保证计算出来的结果总是正确的，一般只能判定所给解的正确性不小于p（1/2&lt;p&lt;1）</li>
<li>通过算法的反腐执行（即以增大算法的执行时间为代价），能够使发生错误的概率小到可以忽略的程度。</li>
<li>由于每次执行的算法是独立的，故k次执行均发生错误的概率为（1-p）^k。</li>
<li>对于判定问题（回答只能是“Yes”或“No”）<ul>
<li>带双错的(two-sided error)：回答“Yes”或“No”都有可能错。</li>
<li>带单错的(one-sided error)：只有一种回答可能错。</li>
</ul>
</li>
<li>Las Vegas算法可以看成是单错概率为0的Monte Carlo算法。</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>在不允许发生错误的应用中（人造飞船、电网控制等），Monte Carlo算法不可以使用</li>
<li>若以小概率的出错允许的话，Monte Carlo算法比Las Vegas算法要节省许多时间，所以经常被采用。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>对于某一给定的问题，随机算法所需的时间和空间复杂性，往往比当前的已知的、最好的确定性算法要好。</li>
<li>到目前为止设计出来的各种随机算法，无论是理解上还是实现上，都是极为简单的。</li>
<li>随机算法避免了去构造最坏情况的例子。</li>
</ul>
<h5 id="举例：Testing-String-Equality"><a href="#举例：Testing-String-Equality" class="headerlink" title="举例：Testing String Equality"></a>举例：Testing String Equality</h5><h4 id="Sherwood随机化方法（属Las-Vegas算法）"><a href="#Sherwood随机化方法（属Las-Vegas算法）" class="headerlink" title="Sherwood随机化方法（属Las Vegas算法）"></a>Sherwood随机化方法（属Las Vegas算法）</h4><ul>
<li>如果某个问题已经有了一个平均情况下较好的确定性算法，但是该算法在最坏情况下效率不高，此时<em>引入一个随机数发生器</em>（通常是服从均匀分布，根据问题需要也可以产生其他的分布），可将一个确定性算法改成一个随机算法，使得对于任何输入实例，该算法在概率意义下都有很好的性能。（Select，QuickSort）</li>
<li>如果算法（所给的确定性算法）无法直接使用Sherwood方法，则可以<em>采用随机预处理的方法，使得输入对象服从均匀分布</em>（或其他分布），然后再用确定性算法对其进行处理。所得效果在概率意义下与Sherwood型算法相同。</li>
<li>Sherwood算法总能求得问题的一个解，且所求得的解一定是正确的。</li>
<li>当一个确定性算法在最坏情况和平均情况下的时间复杂度有较大差别时，可在确定性算法中引入随机性将其改造为Sherwood算法，以消除或减少问题的好坏输入实例间的差别。</li>
</ul>
]]></content>
      <categories>
        <category>learn algorithm</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-5</title>
    <url>/2019/11/18/algorithm-5/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>适用于求解最优化问题的算法往往包含一系列步骤，每一步都有一组选择。</li>
<li>贪心算法总是作出在当前看来是最好的选择。</li>
<li>贪心算法并不从整体最优上加以考虑，他所作出的选择只是在某种意义上的局部最优选择。</li>
<li>贪心算法不能对所有问题都得到整体最优解，但对许多问题他能产生整体最优解。</li>
<li>在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</li>
<li>与动态规划方法相比，贪心算法更简单，更直接。</li>
</ul><a id="more"></a>
<h4 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h4><ol>
<li>最优子结构性质</li>
<li>贪心选择性质：贪心算法通过做一系列的选择来给出某一问题的最优解。他所作出的每一个选择当前状态下的最好选择（局部），即贪心选择。</li>
</ol>
<h4 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h4><ul>
<li>是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。</li>
<li>这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</li>
<li>动态规划算法通常以自底向上的方式解决各子问题。</li>
<li>贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每做一次贪心选择就将所求问题简化为规模更小的子问题。</li>
</ul>
<h4 id="重要实例"><a href="#重要实例" class="headerlink" title="重要实例"></a>重要实例</h4><ul>
<li><p>单源最短路径</p>
<p> <code>Dijkstra算法</code></p>
</li>
<li><p>最小生成树</p>
<p> <code>Prim算法</code> <code>Kruskal算法</code></p>
</li>
<li><p>哈弗曼编码</p>
</li>
</ul>
]]></content>
      <categories>
        <category>learn algorithm</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-4</title>
    <url>/2019/11/18/algorithm-4/</url>
    <content><![CDATA[<h1 id="动态规划（dynamic-programing）"><a href="#动态规划（dynamic-programing）" class="headerlink" title="动态规划（dynamic programing）"></a>动态规划（dynamic programing）</h1><h4 id="分治法求解"><a href="#分治法求解" class="headerlink" title="分治法求解"></a>分治法求解</h4><p>子问题相互独立，不包含公共子问题。</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul>
<li>与分治法类似，也是将问题分解为规模逐渐减小的同类型的子问题。</li>
<li>与分治法不同的是，分解得到的子问题往往不是互相独立的。</li>
</ul><a id="more"></a>

<h4 id="相关的重要概念"><a href="#相关的重要概念" class="headerlink" title="相关的重要概念"></a>相关的重要概念</h4><ul>
<li>子问题的高度重复性</li>
<li>最优子结构性质：问题的最优解中包含着其中每一个子问题的最优解。</li>
</ul>
<h4 id="适用于用动态规划解决的问题"><a href="#适用于用动态规划解决的问题" class="headerlink" title="适用于用动态规划解决的问题"></a>适用于用动态规划解决的问题</h4><ul>
<li>若一个问题可以分解为若干个高度重复的子问题，且问题也具有组柚子结构性质，就可用动态规划进行求解。</li>
<li>具体方式：可以地推的方式逐层计算最优值并记录必要的信息，最后根据记录的信息构造最优解。</li>
</ul>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>用一个表来记录所有已解决的子问题的答案，不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。（保存已解决的子问题的答案，在需要时使用，从而避免大量重复计算）</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>找出最优解的性质，并刻画其结构特征。</li>
<li>递归的定义最优值。</li>
<li>以自底向上的方式计算最优值。</li>
<li>根据计算最优值时得到的信息，构造最优解。</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//暴力法 O(n^3)</span><br><span class="line">public static int get_smallest_sum(int[] a) &#123;</span><br><span class="line">		int max_sum = 0, current_sum = 0;</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			for (int j = i + 1; j &lt; a.length; j++) &#123;</span><br><span class="line">				current_sum = 0;</span><br><span class="line">				for (int k = i; k &lt; j; k++) &#123;//从i+到j，用k遍历</span><br><span class="line">					current_sum += a[k];</span><br><span class="line">					if (current_sum &gt; max_sum)</span><br><span class="line">						max_sum = current_sum;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return max_sum;</span><br><span class="line">	&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//暴力法 O(n^2)</span><br><span class="line">public static int get_smallest_sum(int[] a) &#123;</span><br><span class="line">		int max_sum = 0, current_sum = 0, len = 0;</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			current_sum = a[i];</span><br><span class="line">			for (int j = i + 1; j &lt; a.length; j++) &#123;//从i开始往后面加，遍历往后加的个数</span><br><span class="line">				current_sum += a[j];</span><br><span class="line">				if (current_sum &gt; max_sum)</span><br><span class="line">					max_sum = current_sum;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		return max_sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//动态规划 取（当前和+当前值）（当前值）的较大值作为更新后的当前较大和</span><br><span class="line">//currentSum[i]=max&#123;currentSum[i-1],arr[i]&#125;</span><br><span class="line">public static int maxSum(int[] arr) &#123;</span><br><span class="line">	int sum = 0, currentSum = 0;</span><br><span class="line">	for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">		currentSum = ((currentSum + arr[i]) &gt; arr[i]) ? currentSum + arr[i] : arr[i];</span><br><span class="line">		if (currentSum &gt; sum) &#123;</span><br><span class="line">			sum = currentSum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learn algorithm</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-3</title>
    <url>/2019/11/17/algorithm-3/</url>
    <content><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>递归函数：用函数自身给出定义的函数</li>
<li>递归算法：一个算法包含对自身的调用，这种调用可以是直接的，也可以是间接地。</li>
</ul><a id="more"></a>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="阶乘函数"><a href="#阶乘函数" class="headerlink" title="阶乘函数"></a>阶乘函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int factorial(int n)&#123;</span><br><span class="line">		if(n==0) return 1;</span><br><span class="line">		else</span><br><span class="line">			return factorial(n-1)*n;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Fibonacci数列"><a href="#Fibonacci数列" class="headerlink" title="Fibonacci数列"></a>Fibonacci数列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int fibonacci(int n)&#123;</span><br><span class="line">		if(n==1||n==2) return 1;</span><br><span class="line">		else</span><br><span class="line">			return fibonacci(n-1)+fibonacci(n-2);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a>整数划分问题</h5><p>将正整数n表示成一系列正整数之和：<strong>n=n1+n2+…+nk</strong>，其中<strong>n1</strong>≥n2≥…≥nk≥1，k≥1。<br>正整数n的这种表示称为正整数n的划分。求正整数n的不同划分个数。<br>例如：正整数6有如下11种不同的划分：<br>6；<br>5+1；<br>4+2，4+1+1；<br>3+3，3+2+1，3+1+1+1；<br>2+2+2，2+2+1+1，2+1+1+1+1；<br>1+1+1+1+1+1。</p>
<p>一些经典的递归问题（阶乘，斐波那契），问题本身都具有比较明显的递归关系，因而容易用递归函数直接求解。</p>
<p>在本例中，如果设p(n)为正整数n的划分数，则难以找到递归关系，因此考虑增加一个自变量：将<strong>最大加数n1不大于m的划分个数记作q(n,m)</strong>。可以建立q(n,m)的如下递归关系。（若不理解加粗部分，建议把题目多读几遍）</p>
<p>(1) q(n,1)=1, n≥1; 当最大加数n1不大于1时，任何正整数n只有一种划分形式， 即n=1+1+…+1(n个1)</p>
<p>(2) q(n,m)=q(n,n), m ≥ n;<br>最大加数n1实际上不能大于n。因此，q(1,m)=1。</p>
<p>(3) q(n,n)=1+q(n,n-1);<br>正整数n的划分由n1=n的划分和n1 ≤ n-1的划分组成。</p>
<p>(4) q(n,m)=q(n,m-1)+q(n-m,m), n＞m＞ 1;<br>正整数n的最大加数n1不大于m的划分，由n1≤ m-1 的划分和n1=m的划分组成。n1=m 的划分就是该划分中必然包含数m，因此其划分的数目与n-m的m划分一致。</p>
<p>如果设p(n)为正整数n的划分数，则难以找到递归关系，因此考虑增加一个自变量：将最大加数n1不大于m的划分个数记作q(n,m)。可以建立q(n,m)的如下递归关系。（正整数n的划分数p(n)=q(n,n)。 ）</p>
<h6 id="q-n-m-q-当前需要被划分的数字，划分中的加数的最大取值"><a href="#q-n-m-q-当前需要被划分的数字，划分中的加数的最大取值" class="headerlink" title="q(n,m)=q(当前需要被划分的数字，划分中的加数的最大取值)"></a>q(n,m)=q(当前需要被划分的数字，划分中的加数的最大取值)</h6><p><img src="/imgs/algorithm/integerdiv.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int q(int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    if((n &lt; 1) || (m &lt; 1)) //无意义情况 </span><br><span class="line">        return 0;</span><br><span class="line">    if((n == 1) || (m == 1))//数字1，划分最大加数为1的划分只会有1种 </span><br><span class="line">        return 1;</span><br><span class="line">    if(n &lt; m)			   //需要划分的数字n，实际情况不会小于其划分最大加数 </span><br><span class="line">        return q(n, n);</span><br><span class="line">    if(n == m)				//正整数n的划分由n1=n的划分和n1 ≤ n-1的划分组成。 </span><br><span class="line">        return q(n, m - 1) + 1;</span><br><span class="line">    return q(n, m - 1) + q(n - m, m);//被划分数为n，最大划分加数为m的划分数目，等于， </span><br><span class="line">	// 被划分数为n最大加数为m-1的划分数目 + 被划分数为（n-m）最大加数为m的划分数目   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int	main()</span><br><span class="line">&#123;</span><br><span class="line">    int	m = 6, n = 6;</span><br><span class="line">    for(int i=1;i&lt;=6;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	cout &lt;&lt;&quot;  数字为&quot;&lt;&lt;n&lt;&lt;&quot;时，最大划分加数上限为&quot;&lt;&lt;i&lt;&lt;&quot;时的划分情况有&quot;&lt;&lt; q(n, i) &lt;&lt;&quot;种&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归的优点"><a href="#递归的优点" class="headerlink" title="递归的优点"></a>递归的优点</h4><p>结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，为设计算法、调试程序提供了很大的便利。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>递归算法的运行效率较低，生成的子递归多有重复。</p>
<h4 id="递归式的解法："><a href="#递归式的解法：" class="headerlink" title="递归式的解法："></a>递归式的解法：</h4><ul>
<li>代换法（substitution method）：猜测解并用数学归纳法证明。</li>
<li>递归树方法（recursion-tree method）</li>
<li>主方法（master method）</li>
</ul>
<h5 id="递归树"><a href="#递归树" class="headerlink" title="递归树"></a>递归树</h5><p>学习 <a href="https://blog.csdn.net/every__day/article/details/86554857" target="_blank" rel="noopener">https://blog.csdn.net/every__day/article/details/86554857</a> </p>
<h5 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h5><p>学习 <a href="https://blog.csdn.net/jal517486222/article/details/82805401" target="_blank" rel="noopener">https://blog.csdn.net/jal517486222/article/details/82805401</a> </p>
<ul>
<li>值得注意的是，这三种情况并没有覆盖所有的<code>f（n）</code>，应用时需要注意是否符合这三种情况。</li>
</ul>
<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h4 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h4><ul>
<li>分解（Divide）：将原问题分解为子问题</li>
<li>解决（Conquer）：求解子问题</li>
<li>合并（Combine）：组合子问题的解得到原问题的解。</li>
</ul>
<h4 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h4><ul>
<li>问题的规模缩小到一定程度就可以容易地解决。</li>
<li>问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>基于子问题的解可以合并为原问题的解。</li>
<li>问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li>
</ul>
<h4 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h4><ul>
<li><p>使子问题规模尽量接近的做法，就是平衡。</p>
</li>
<li><p>在使用分治法和递归时，要尽量把问题分成规模相等，或至少是规模相近的子问题以提高算法的效率。</p>
</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort(int arr[])&#123;</span><br><span class="line">		if(arr ==null||arr.length&lt;=1) return;//数组为空或长度小于一，不用操作</span><br><span class="line">		quickSort(arr,0,arr.length);//注意右端口为数组长度，直接arr[right]会越界</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void quickSort(int arr[],int left,int right)&#123;</span><br><span class="line">		if (right - left &lt;= 1)    return;//递归的终止条件</span><br><span class="line">		int part = partition(arr,left,right);//得到坑值该在的位置</span><br><span class="line">		quickSort(arr, left, part);//左右分别排序</span><br><span class="line">		quickSort(arr, part+1, right);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    private static int partition(int[] arr, int low, int high) &#123;</span><br><span class="line">    	int pivot = arr[low];//一开始确定坑值和坑的位置。</span><br><span class="line">    	int left = low;</span><br><span class="line">    	int right=high-1;//解决数组长度越界</span><br><span class="line">    	while(left&lt;right)&#123;</span><br><span class="line">    		while(left&lt;right&amp;&amp;pivot&lt;=arr[right])</span><br><span class="line">    			--right;//从右边开始找，找到第一个比pivot值小的值</span><br><span class="line">    		arr[left]=arr[right];//把这个第一个比pivot值小的值放到左边</span><br><span class="line">    		while(left&lt;right&amp;&amp;pivot&gt;=arr[left])</span><br><span class="line">    			++left;//从左边开始找，找到第一个比pivot值大的值</span><br><span class="line">    		arr[right]=arr[left];//把这个第一个比pivot值大的值放到右边</span><br><span class="line">    	&#125;</span><br><span class="line">    	arr[left]=pivot;//把开始的坑值填到后面的坑，这里left=right，都可以</span><br><span class="line">    	print(arr);</span><br><span class="line">		return left;//返回坑所在的位置</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learn_algorithm</category>
      </categories>
      <tags>
        <tag>递归与分治</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-2</title>
    <url>/2019/11/17/algorithm-2/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int[] insertSort(int[] a) &#123;</span><br><span class="line">	int j, t;</span><br><span class="line">	for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">		for (j = 0; j &lt; i; j++) &#123;</span><br><span class="line">			if (a[j] &gt; a[i])</span><br><span class="line">				break;//找到第一个前面的大于后面的</span><br><span class="line">		&#125;</span><br><span class="line">		t = a[i];//保存后面的</span><br><span class="line">		for (int k = i - 1; k &gt;= j; k--) &#123;</span><br><span class="line">			a[k + 1] = a[k];//全部后移一位</span><br><span class="line">		&#125;</span><br><span class="line">		a[j] = t;//把后面的值放到前面    2 4 5 0-&gt; 2 4 5 后移一位保存t=0，把第一个位置等于t-&gt;0 2 4 5</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>

<ul>
<li>最好情况运行时间：输入数组已经排好序</li>
<li>最好情况运行时间：问题要求最终按照递增的顺序排序但输入数组是递减排序。</li>
</ul>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>分而治之(divide - conquer);每个递归过程涉及三个步骤<br>第一, 分解: 把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素.<br>第二, 治理: 对每个子序列分别调用归并排序MergeSort, 进行递归操作<br>第三, 合并: 合并两个排好序的子序列,生成排序结果. </p>
<p><img src="/imgs/algorithm/merge.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int[] sort(int[] a,int low,int high)&#123;</span><br><span class="line">        int mid = (low+high)/2;</span><br><span class="line">        if(low&lt;high)&#123;</span><br><span class="line">            sort(a,low,mid);</span><br><span class="line">            sort(a,mid+1,high);</span><br><span class="line">            //左右归并</span><br><span class="line">            merge(a,low,mid,high);</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void merge(int[] a, int low, int mid, int high) &#123;</span><br><span class="line">        int[] temp = new int[high-low+1];</span><br><span class="line">        int i= low;</span><br><span class="line">        int j = mid+1;</span><br><span class="line">        int k=0;</span><br><span class="line">        // 把较小的数先移到新数组中</span><br><span class="line">        while(i&lt;=mid &amp;&amp; j&lt;=high)&#123;</span><br><span class="line">            if(a[i]&lt;a[j])&#123;</span><br><span class="line">                temp[k++] = a[i++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 把左边剩余的数移入数组 </span><br><span class="line">        while(i&lt;=mid)&#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把右边边剩余的数移入数组</span><br><span class="line">        while(j&lt;=high)&#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把新数组中的数覆盖nums数组</span><br><span class="line">        for(int x=0;x&lt;temp.length;x++)&#123;</span><br><span class="line">            a[x+low] = temp[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p><strong>（1）稳定性</strong><br>   　归并排序是一种稳定的排序。<br><strong>（2）存储结构要求</strong><br>  　可用顺序存储结构。也易于在链表上实现。<br><strong>（3）时间复杂度</strong><br>  　对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。<br><strong>（4）空间复杂度</strong><br>   需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。<br> 注意：<br>  　若用单链表做存储结构，很容易给出就地的归并排序</p>
]]></content>
      <categories>
        <category>learn_algorithm</category>
      </categories>
      <tags>
        <tag>InsertSort</tag>
        <tag>MergeSort</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-1</title>
    <url>/2019/11/17/algorithm-1/</url>
    <content><![CDATA[<h1 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h1><h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><p>通俗地讲，算法是指解决问题的一种方法或一个过程。更严格地讲，算法是由若干条指令组成的有穷序列，且满足下述四条性质。</p><a id="more"></a>
<ol>
<li>输入：有零个或多个由外部提供的量作为算法的输入。</li>
<li>输出：算法产生至少一个量作为输出。</li>
<li>确定性：组成算法的每条指令是清晰的，无歧义的。</li>
<li>有限性：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的。</li>
</ol>
<p>有的定义是这样的</p>
<ol>
<li>确定性：每条指令都是明确的、无二义的。</li>
<li>能行性：每条指令都必须是能够执行的。</li>
<li>输入：允许有0个或多个输入量，曲子特定的集合。</li>
<li>输出：产生一个或多个输出，它们与输入量之间存在着某种特定的关系。</li>
<li>有穷性：每条指令执行的次数都是有穷的。</li>
</ol>
<h3 id="算法定义上的解释"><a href="#算法定义上的解释" class="headerlink" title="算法定义上的解释"></a>算法定义上的解释</h3><ul>
<li>有穷指令序列若满足上述五条，即确定性、能行性、输入、输出和有穷性，则通常称之为算法。</li>
<li>若满足前四条而不满足第五条（有穷性）的有穷指令序列通常称之为计算过程。</li>
<li>只要不停电、机器不坏，计算过程就可以永远执行下去（死循环）。</li>
<li>永远执行的计算过程并非毫无用处——OS就是计算过程。</li>
</ul>
<h2 id="算法的“好坏”如何衡量"><a href="#算法的“好坏”如何衡量" class="headerlink" title="算法的“好坏”如何衡量"></a>算法的“好坏”如何衡量</h2><p>算法复杂性的高低体现在运行该算法所需要的计算机资源上，所需资源越多，该算法的复杂性越高；反之，所需资源越少，该算法的复杂性越低。对计算机资源，最重要的是时间和空间（即存储器）资源。因此，算法的复杂性有时间复杂度和空间复杂度之分。</p>
<h2 id="描述算法时间复杂度"><a href="#描述算法时间复杂度" class="headerlink" title="描述算法时间复杂度"></a>描述算法时间复杂度</h2><ul>
<li><p>用问题规模的某个函数来表示算法的基本运算量，这个表示基本运算量的函数称之为算法的时间复杂度。</p>
</li>
<li><p>时间复杂度用<code>T(n)</code>（或<code>T(n,m)</code>）表示</p>
<p>​    <code>T(n)=5n</code></p>
<p>​    <code>T(n)=3nlogn</code></p>
<p>   <code>T(n)=2^n</code></p>
</li>
</ul>
<h3 id="表示渐进表示算法复杂度的符号：O、Ω、θ。"><a href="#表示渐进表示算法复杂度的符号：O、Ω、θ。" class="headerlink" title="表示渐进表示算法复杂度的符号：O、Ω、θ。"></a>表示渐进表示算法复杂度的符号：<code>O</code>、<code>Ω</code>、<code>θ</code>。</h3><p><code>O</code>表示上界，可以理解为<code>≤</code>，<code>Ω</code>表示下界，可以理解为<code>≥</code> ，而<code>θ</code> 既表示上界，也表示下界，所以可以理解为确界。需要补充的是，小写的<code>o</code>表示上界，理解为<code>＜</code>，小写的<code>w</code>表示下界，理解为<code>＞</code>。</p>
<p>举例：<br>$$<br>T(n)=n^3+n^2<br>$$<br>用大O表示法的时间复杂度为<code>O（n^3</code>）,<code>O(n^4)</code>  ……</p>
<p>用Ω表示法的时间复杂度为<code>Ω(n^3)</code>,<code>Ω（n^2））</code>，<code>Ω（n）</code>  ……</p>
<p>用θ表示法的时间复杂度为<code>θ(n^3)</code></p>
]]></content>
      <categories>
        <category>learn_algorithm</category>
      </categories>
      <tags>
        <tag>算法定义</tag>
      </tags>
  </entry>
  <entry>
    <title>学习设计模式-1</title>
    <url>/2019/11/16/designPattern-1/</url>
    <content><![CDATA[<h1 id="实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。"><a href="#实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。" class="headerlink" title="实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。"></a>实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//最原始的做法</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(&quot;请输入数字A：&quot;);</span><br><span class="line">        string A = Console.ReadLine();</span><br><span class="line">        Console.Write(&quot;请选择运算符号(+、-、*、/)：&quot;);</span><br><span class="line">        string B = Console.ReadLine();</span><br><span class="line">        Console.Write(&quot;请输入数字B：&quot;);</span><br><span class="line">        string C = Console.ReadLine();</span><br><span class="line">        string D = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        if (B == &quot;+&quot;)</span><br><span class="line">            D = Convert.ToString(Convert.ToDouble(A) + Convert.ToDouble(C));</span><br><span class="line">        if (B == &quot;-&quot;)</span><br><span class="line">            D = Convert.ToString(Convert.ToDouble(A) - Convert.ToDouble(C));</span><br><span class="line">        if (B == &quot;*&quot;)</span><br><span class="line">            D = Convert.ToString(Convert.ToDouble(A) * Convert.ToDouble(C));</span><br><span class="line">        if (O == &quot;/&quot;)</span><br><span class="line">            D = Convert.ToString(Convert.ToDouble(A) / Convert.ToDouble(C));</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(&quot;结果是：&quot; + D);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//变量名规范以及捕获异常后</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(&quot;请输入数字A：&quot;);</span><br><span class="line">            string strNumberA = Console.ReadLine();</span><br><span class="line">            Console.Write(&quot;请选择运算符号(+、-、*、/)：&quot;);</span><br><span class="line">            string strOperate = Console.ReadLine();</span><br><span class="line">            Console.Write(&quot;请输入数字B：&quot;);</span><br><span class="line">            string strNumberB = Console.ReadLine();</span><br><span class="line">            string strResult = &quot;&quot;;</span><br><span class="line">            switch (strOperate)</span><br><span class="line">            &#123;</span><br><span class="line">                case &quot;+&quot;:</span><br><span class="line">                    strResult = Convert.ToString(Convert.ToDouble(strNumberA) </span><br><span class="line">                        + Convert.ToDouble(strNumberB));</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;-&quot;:</span><br><span class="line">                    strResult = Convert.ToString(Convert.ToDouble(strNumberA) </span><br><span class="line">                        - Convert.ToDouble(strNumberB));</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;*&quot;:</span><br><span class="line">                    strResult = Convert.ToString(Convert.ToDouble(strNumberA) </span><br><span class="line">                        * Convert.ToDouble(strNumberB));</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;/&quot;:</span><br><span class="line">                    if (strNumberB != &quot;0&quot;)</span><br><span class="line">                        strResult = Convert.ToString(Convert.ToDouble(strNumberA) </span><br><span class="line">                              / Convert.ToDouble(strNumberB));</span><br><span class="line">                    else</span><br><span class="line">                        strResult = &quot;除数不能为0&quot;;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;结果是：&quot; + strResult);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;您的输入有错：&quot; + ex.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//业务逻辑与界面逻辑分开，降低耦合</span><br><span class="line">//Operation运算类</span><br><span class="line"></span><br><span class="line">public class Operation</span><br><span class="line">&#123;</span><br><span class="line">    public static double GetResult(double numberA, double numberB, string operate)</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0d;</span><br><span class="line">        switch (operate)</span><br><span class="line">        &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                result = numberA + numberB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                result = numberA - numberB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                result = numberA * numberB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;/&quot;:</span><br><span class="line">                result = numberA / numberB;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端代码</span><br><span class="line"></span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(&quot;请输入数字A：&quot;);</span><br><span class="line">        string strNumberA = Console.ReadLine();</span><br><span class="line">        Console.Write(&quot;请选择运算符号(+、-、*、/)：&quot;);</span><br><span class="line">        string strOperate = Console.ReadLine();</span><br><span class="line">        Console.Write(&quot;请输入数字B：&quot;);</span><br><span class="line">        string strNumberB = Console.ReadLine();</span><br><span class="line">        string strResult = &quot;&quot;;</span><br><span class="line">        strResult = Convert.ToString(Operation.GetResult(Convert.ToDouble(strNumberA),</span><br><span class="line">        Convert.ToDouble(strNumberB), strOperate));</span><br><span class="line">        Console.WriteLine(&quot;结果是：&quot; + strResult);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;您的输入有错：&quot; + ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//使用继承和多态后</span><br><span class="line">//Operation运算类</span><br><span class="line"></span><br><span class="line">public class Operation</span><br><span class="line">&#123;</span><br><span class="line">    private double _numberA = 0;</span><br><span class="line">    private double _numberB = 0;</span><br><span class="line">    </span><br><span class="line">    public double NumberA</span><br><span class="line">    &#123;</span><br><span class="line">        get  &#123;  return _numberA;  &#125;</span><br><span class="line">        set  &#123;  _numberA = value;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public double NumberB</span><br><span class="line">    &#123;</span><br><span class="line">        get  &#123;  return _numberB;  &#125;</span><br><span class="line">        set  &#123;  _numberB = value;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0; </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运算类</span><br><span class="line">class OperationAdd : Operation</span><br><span class="line">&#123;</span><br><span class="line">    public override double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0; </span><br><span class="line">        result = NumberA + NumberB;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OperationSub : Operation</span><br><span class="line">&#123;</span><br><span class="line">   public override double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0;</span><br><span class="line">        result = NumberA - NumberB;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OperationMul : Operation</span><br><span class="line">&#123;</span><br><span class="line">    public override double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0;</span><br><span class="line">        result = NumberA * NumberB;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OperationDiv : Operation</span><br><span class="line">&#123;</span><br><span class="line">    public override double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0;</span><br><span class="line">        if (NumberB==0)</span><br><span class="line">            throw new Exception(&quot;除数不能为0。&quot;);</span><br><span class="line">        result = NumberA / NumberB;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//简单运算工厂类实现</span><br><span class="line"></span><br><span class="line">public class OperationFactory</span><br><span class="line">&#123;</span><br><span class="line">    public static Operation createOperate(string operate)</span><br><span class="line">    &#123;</span><br><span class="line">        Operation oper = null;</span><br><span class="line">        switch (operate)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                oper = new OperationAdd();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                oper = new OperationSub();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                oper = new OperationMul();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;/&quot;:</span><br><span class="line">                oper = new OperationDiv();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端代码</span><br><span class="line">Operation oper;</span><br><span class="line">oper = OperationFactory.createOperate(&quot;+&quot;);</span><br><span class="line">oper.NumberA = 1;</span><br><span class="line">oper.NumberB = 2;</span><br><span class="line">double result = oper.GetResult();</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="代码的目标："><a href="#代码的目标：" class="headerlink" title="代码的目标："></a>代码的目标：</h6><ul>
<li>可维护</li>
<li>可复用</li>
<li>可扩展</li>
<li>灵活性</li>
</ul>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>学习面向对象的分析设计编程思想，通过封装、继承、多态降低程序的耦合性，使用设计模式使得程序更加灵活，容易修改，并且容易复用。</p>
]]></content>
      <categories>
        <category>learn designPattern</category>
        <category>简单工厂模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>学习springboot-1</title>
    <url>/2019/11/16/springboot-1/</url>
    <content><![CDATA[<h1 id="springboot注解的使用"><a href="#springboot注解的使用" class="headerlink" title="springboot注解的使用"></a>springboot注解的使用</h1><p><code>@Value</code>：写在定义单个变量前，与<code>application.yml</code>中的相应位置相对应。</p><a id="more"></a>
<p><code>@Component</code>：表明该类是一个组件，表明后才能使用<code>@Autowired</code>进行自动装配。</p>
<p><code>@ConfigurationProperties</code>：<code>@Value</code>的升级版，直接把一个类的所有变量与<code>application.yml</code>的相应变量组相对应。</p>
<p><code>@RestController</code>：等于<code>@ResponseBody</code>+<code>@Controller</code>作用之和</p>
<p><code>@PathVariable</code>：获取url中的数据，用这种方式获取rest风格的url中的id值，如</p>
<p>访问的url为：<code>localhost:8080/execution/100</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/execution/&#123;id&#125;&quot;)</span><br><span class="line">public String methods(@PathVariable(&quot;id&quot;)Integer id)&#123;</span><br><span class="line">     return &quot;id=&quot;+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>@RequestParam</code>：获取请求参数的值，</p>
<p>访问的url为：<code>localhost:8080/execution?id=100</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/execution&quot;)</span><br><span class="line">public String methods(@RequestParam(&quot;id&quot;)Integer id)&#123;</span><br><span class="line">     return &quot;id=&quot;+id;</span><br><span class="line">&#125;</span><br><span class="line">//这里的参数可以不传或设置默认值</span><br><span class="line">@GetMapping(&quot;/execution&quot;)</span><br><span class="line">public String methods(@RequestParam(value= &quot;id&quot;, required = false, defaultValue = &quot;0&quot;)Integer id)&#123;</span><br><span class="line">     return &quot;id=&quot;+id; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>@Transactional</code>：开启事务，注意这只是对java程序的设置，真正能否实现还得看数据库是否支持事务，如发现开启事务后，数据库仍未支持事务，这是可能需要更换数据库引擎（如<code>mysql</code>的设置成<code>InnoDB</code>）。<code>navicate</code>更改方式如下（先打开<code>设计表</code>，全选所有字段后，然后选择<code>选项</code>）。</p>
<p><img src="/imgs/springboot-1/springboot1.png" alt>_</p>
<p><code>@Valid</code>注解与实体类中对应属性上的限制注解，如<code>@Min</code>、<code>NotEmpty</code>等相结合，实现表单验证功能。</p>
<p>如<code>@Min(value = 18,message = &quot;msg&quot;)</code> 表明最小值为18，如错误则设置<code>message</code>为<code>msg</code>，同时在<code>@Valid</code>使用后，添加<code>BindingResult bindingResult</code>参数，通过<code>BindingResult</code>的<code>hasErrors</code>方法判断是否错误，同时可以通过<code>BindingResult</code>的<code>getFieldError</code>的<code>getDefaultMessage</code> 方法得到实体类中设置的<code>message</code>值。</p>
<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Girl实体类中</span><br><span class="line">@Min(Value = 18,message = &quot;年龄不能小于18岁&quot;)</span><br><span class="line">private Integer age;</span><br><span class="line"></span><br><span class="line">//调用表单方法中</span><br><span class="line">public void methods(@Valid Girl girl,BindingResult bindingResult)&#123;</span><br><span class="line">	if(bindingResult.hasErrors())&#123;</span><br><span class="line">		System.out.println(bindingResult.getFieldError().getDefaultMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AOP统一处理日志请求"><a href="#AOP统一处理日志请求" class="headerlink" title="AOP统一处理日志请求"></a>AOP统一处理日志请求</h1><ul>
<li><p>AOP是一种编程范式，与语言无关，是一种程序设计思想。</p>
<p>   ~  面向切面（AOP）Aspect Oriented Programing</p>
<p>   ~  面向对象（OOP）Object Oriented Programing</p>
<p>   ~  面向过程（POP）Procedure Oriented Programing           <em>如C语言。</em></p>
</li>
</ul>
]]></content>
      <categories>
        <category>learn_springboot</category>
      </categories>
  </entry>
  <entry>
    <title>test_markdown</title>
    <url>/2019/11/15/test-markdown/</url>
    <content><![CDATA[<p><code>显示什么呢</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">here is </span><br><span class="line">the code </span><br><span class="line">of the </span><br><span class="line">program</span><br></pre></td></tr></table></figure><h1 id="这是一级标题？"><a href="#这是一级标题？" class="headerlink" title="这是一级标题？"></a>这是一级标题？</h1><hr><h2 id="二级标题？"><a href="#二级标题？" class="headerlink" title="二级标题？"></a>二级标题？</h2><a id="more"></a>



<h3 id="三级标题？"><a href="#三级标题？" class="headerlink" title="三级标题？"></a>三级标题？</h3><p><em>我是斜体吗</em></p>
<p><strong>我加粗了吗</strong></p>
<hr>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong><code>总结：</code></strong></h1><p>1.使用tags、categories、标题（#）时记得符号后需要一个空格。</p>
<p>如 tags：      # 一级标题   ##   二级标题    ###  三级标题</p>
<p><code>- tags</code></p>
<p>2.斜体 为**， 中间加上斜体内容</p>
<p>3.加粗为** **，中间加上需要加粗的内容</p>
<p>4.高亮块为``</p>
<p>5.代码块为 ``````</p>
]]></content>
      <categories>
        <category>learn-hexo</category>
      </categories>
      <tags>
        <tag>test-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>记录hexo安装和使用的步骤</title>
    <url>/2019/11/14/%E8%AE%B0%E5%BD%95hexo%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>​        这是正式的第一篇文章，想用来介绍晚上使用hexo框架搭建这个博客的过程。</p><p>​        首先，你的电脑需要有git和nodejs这两个工具，可到各自的官网下载，下载完后在命令行下输入git、node、npm验证</p><a id="more"></a>

<p><img src="/imgs/first/git.png" alt></p>
<p><img src="/imgs/first/node.png" alt></p>
<p><img src="/imgs/first/npm.png" alt></p>
<p>​        安装完后新建一个博客的目录文件，在我这里为D:/code/blog，</p>
<p>通过命令行跳转到该项目，注意由C盘到D盘的命令为D:  ，而不是cd d:  ,或其他。</p>
<p><img src="/imgs/first/c_d.png" alt></p>
<p>​        然后通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>​        初始化改目录，使其成为一个hexo博客文件夹。</p>
<p>​        接着通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n test</span><br></pre></td></tr></table></figure>

<p>创建一篇名为test的新文章。此时会在blog/source/_posts目录下新建test.md文件，即为该文章的源文件。</p>
<p>​        编写好文章内容后，通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>清理文件夹内容，然后通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>生成文章在hexo的可展示的文件，在blog/public/2019的文件夹下。</p>
<p>最后通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>启动服务器。这样在localhost:4000下就能访问到博客的主页了（默认端口是4000，如不可访问可能是其他端口冲突）。</p>
<p>部署到github的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo学习与使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2019/11/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>这个是Eoogle的第一篇博客</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>categories测试</category>
        <category>categories test</category>
      </categories>
      <tags>
        <tag>tags</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
