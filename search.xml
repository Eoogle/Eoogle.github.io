<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从零开始学java-2</title>
    <url>/blog/2019/11/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6java-2/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的概念：是一种容器，可以同时存放多个数据值。</p><p>数组的特点：</p><ol>
<li>数组是一种引用数据类型</li>
<li>数组当中的多个数据，类型必须统一</li>
<li>数组的长度在程序运行期间不可改变</li>
</ol><a id="more"></a>


<p>数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。</p>
<p>两种常见的初始化方式：</p>
<ol>
<li>动态初始化（指定长度）</li>
<li>静态初始化（指定内容）</li>
</ol>
<p>动态初始化数组的格式：<br>数据类型[] 数组名称 = new 数据类型[数组长度];</p>
<p>解析含义：<br>左侧数据类型：也就是数组当中保存的数据，全都是统一的什么类型<br>左侧的中括号：代表我是一个数组<br>左侧数组名称：给数组取一个名字<br>右侧的new：代表创建数组的动作<br>右侧数据类型：必须和左边的数据类型保持一致<br>右侧中括号的长度：也就是数组当中，到底可以保存多少个数据，是一个int数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day05.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个数组，里面可以存放300个int数据</span></span><br><span class="line">        <span class="comment">// 格式：数据类型[] 数组名称 = new 数据类型[数组长度];</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组，能存放10个double类型的数据</span></span><br><span class="line">        <span class="keyword">double</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组，能存放5个字符串</span></span><br><span class="line">        String[] arrayC = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day05.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数。</span></span><br><span class="line"><span class="comment">静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">静态初始化基本格式：</span></span><br><span class="line"><span class="comment">数据类型[] 数组名称 = new 数据类型[] &#123; 元素1, 元素2, ... &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">虽然静态初始化没有直接告诉长度，但是根据大括号里面的元素具体内容，也可以自动推算出来长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接创建一个数组，里面装的全都是int数字，具体为：5、15、25</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">40</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组，用来装字符串："Hello"、"World"、"Java"</span></span><br><span class="line">        String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"Java"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day05.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用静态初始化数组的时候，格式还可以省略一下。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">标准格式：</span></span><br><span class="line"><span class="comment">数据类型[] 数组名称 = new 数据类型[] &#123; 元素1, 元素2, ... &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">省略格式：</span></span><br><span class="line"><span class="comment">数据类型[] 数组名称 = &#123; 元素1, 元素2, ... &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1. 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。</span></span><br><span class="line"><span class="comment">2. 静态初始化标准格式可以拆分成为两个步骤。</span></span><br><span class="line"><span class="comment">3. 动态初始化也可以拆分成为两个步骤。</span></span><br><span class="line"><span class="comment">4. 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用建议：</span></span><br><span class="line"><span class="comment">如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略格式的静态初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayA = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态初始化的标准格式，可以拆分成为两个步骤</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayB;</span><br><span class="line">        arrayB = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">11</span>, <span class="number">21</span>, <span class="number">31</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态初始化也可以拆分成为两个步骤</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayC;</span><br><span class="line">        arrayC = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态初始化的省略格式，不能拆分成为两个步骤。</span></span><br><span class="line"><span class="comment">//        int[] arrayD;</span></span><br><span class="line"><span class="comment">//        arrayD = &#123; 10, 20, 30 &#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.day05.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则如下：</span></span><br><span class="line"><span class="comment">如果是整数类型，那么默认为0；</span></span><br><span class="line"><span class="comment">如果是浮点类型，那么默认为0.0；</span></span><br><span class="line"><span class="comment">如果是字符类型，那么默认为'\u0000'；</span></span><br><span class="line"><span class="comment">如果是布尔类型，那么默认为false；</span></span><br><span class="line"><span class="comment">如果是引用类型，那么默认为null。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05ArrayUse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态初始化一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(array); <span class="comment">// 内存地址值</span></span><br><span class="line">        System.out.println(array[<span class="number">0</span>]); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(array[<span class="number">1</span>]); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(array[<span class="number">2</span>]); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(<span class="string">"================="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据123赋值交给数组array当中的1号元素</span></span><br><span class="line">        array[<span class="number">1</span>] = <span class="number">123</span>;</span><br><span class="line">        System.out.println(array[<span class="number">0</span>]); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(array[<span class="number">1</span>]); <span class="comment">// 123</span></span><br><span class="line">        System.out.println(array[<span class="number">2</span>]); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java中内存的使用"><a href="#java中内存的使用" class="headerlink" title="java中内存的使用"></a>java中内存的使用</h4><p><img src="/blog/imgs/java/neicun.png" alt></p>
<hr>
<h2 id="Scanner的使用"><a href="#Scanner的使用" class="headerlink" title="Scanner的使用"></a>Scanner的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day07.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 1. 导包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Scanner类的功能：可以实现键盘输入数据，到程序当中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">引用类型的一般使用步骤：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 导包</span></span><br><span class="line"><span class="comment">import 包路径.类名称;</span></span><br><span class="line"><span class="comment">如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。</span></span><br><span class="line"><span class="comment">只有java.lang包下的内容不需要导包，其他的包都需要import语句。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 创建</span></span><br><span class="line"><span class="comment">类名称 对象名 = new 类名称();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 使用</span></span><br><span class="line"><span class="comment">对象名.成员方法名()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">获取键盘输入的一个int数字：int num = sc.nextInt();</span></span><br><span class="line"><span class="comment">获取键盘输入的一个字符串：String str = sc.next();</span></span><br><span class="line"><span class="comment">其实输入的都是字符串，nextInt会把字符串转为int而已。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Scanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 创建</span></span><br><span class="line">        <span class="comment">// 备注：System.in代表从键盘进行输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取键盘输入的int数字</span></span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"输入的int数字是："</span> + num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取键盘输入的字符串</span></span><br><span class="line">        String str = sc.next();</span><br><span class="line">        System.out.println(<span class="string">"输入的字符串是："</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名对象只能使用一次，可以作为函数的参数或者返回值使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="keyword">new</span> scanner(System.in).netInt();<span class="comment">//只想输入一个数时使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodParam</span><span class="params">(Scanner sc)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title">methodReturn</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Scanner(System.in);&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Random的使用"><a href="#Random的使用" class="headerlink" title="Random的使用"></a>Random的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day07.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Random类用来生成随机数字。使用起来也是三个步骤：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 导包</span></span><br><span class="line"><span class="comment">import java.util.Random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 创建</span></span><br><span class="line"><span class="comment">Random r = new Random(); // 小括号当中留空即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 使用</span></span><br><span class="line"><span class="comment">获取一个随机的int数字（范围是int所有范围，有正负两种）：int num = r.nextInt()</span></span><br><span class="line"><span class="comment">获取一个随机的int数字（参数代表了范围，左闭右开区间）：int num = r.nextInt(3)</span></span><br><span class="line"><span class="comment">实际上代表的含义是：[0,3)，也就是0~2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Random</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = r.nextInt();</span><br><span class="line">        <span class="keyword">int</span> num2 = r.nextInt(<span class="number">10</span>);<span class="comment">//获得0——9的随机数</span></span><br><span class="line">        System.out.println(<span class="string">"随机数是："</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ArrayList的使用"><a href="#ArrayList的使用" class="headerlink" title="ArrayList的使用"></a>ArrayList的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.day07.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组的长度不可以发生改变。</span></span><br><span class="line"><span class="comment">但是ArrayList集合的长度是可以随意变化的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于ArrayList来说，有一个尖括号&lt;E&gt;代表泛型。</span></span><br><span class="line"><span class="comment">泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。</span></span><br><span class="line"><span class="comment">注意：泛型只能是引用类型，不能是基本类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。</span></span><br><span class="line"><span class="comment">如果内容是空，得到的是空的中括号：[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02ArrayList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建了一个ArrayList集合，集合的名称是list，里面装的全都是String字符串类型的数据</span></span><br><span class="line">        <span class="comment">// 备注：从JDK 1.7+开始，右侧的尖括号内部可以不写内容，但是&lt;&gt;本身还是要写的。</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(list); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向集合当中添加一些数据，需要用到add方法。</span></span><br><span class="line">        list.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [赵丽颖]</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        list.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        list.add(<span class="string">"玛尔扎哈"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        list.add(100); // 错误写法！因为创建的时候尖括号泛型已经说了是字符串，添加进去的元素就必须都是字符串才行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.day07.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ArrayList当中的常用方法有：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。</span></span><br><span class="line"><span class="comment">备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。</span></span><br><span class="line"><span class="comment">但是对于其他集合（今后学习）来说，add添加动作不一定成功。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03ArrayListMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(list); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向集合中添加元素：add</span></span><br><span class="line">        <span class="keyword">boolean</span> success = list.add(<span class="string">"柳岩"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [柳岩]</span></span><br><span class="line">        System.out.println(<span class="string">"添加的动作是否成功："</span> + success); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"高圆圆"</span>);</span><br><span class="line">        list.add(<span class="string">"赵又廷"</span>);</span><br><span class="line">        list.add(<span class="string">"李小璐"</span>);</span><br><span class="line">        list.add(<span class="string">"贾乃亮"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [柳岩, 高圆圆, 赵又廷, 李小璐, 贾乃亮]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中获取元素：get。索引值从0开始</span></span><br><span class="line">        String name = list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"第2号索引位置："</span> + name); <span class="comment">// 赵又廷</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中删除元素：remove。索引值从0开始。</span></span><br><span class="line">        String whoRemoved = list.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"被删除的人是："</span> + whoRemoved); <span class="comment">// 李小璐</span></span><br><span class="line">        System.out.println(list); <span class="comment">// [柳岩, 高圆圆, 赵又廷, 贾乃亮]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取集合的长度尺寸，也就是其中元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        System.out.println(<span class="string">"集合的长度是："</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.day07.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">基本类型    包装类（引用类型，包装类都位于java.lang包下）</span></span><br><span class="line"><span class="comment">byte        Byte</span></span><br><span class="line"><span class="comment">short       Short</span></span><br><span class="line"><span class="comment">int         Integer     【特殊】</span></span><br><span class="line"><span class="comment">long        Long</span></span><br><span class="line"><span class="comment">float       Float</span></span><br><span class="line"><span class="comment">double      Double</span></span><br><span class="line"><span class="comment">char        Character   【特殊】</span></span><br><span class="line"><span class="comment">boolean     Boolean</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">从JDK 1.5+开始，支持自动装箱、自动拆箱。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">自动装箱：基本类型 --&gt; 包装类型</span></span><br><span class="line"><span class="comment">自动拆箱：包装类型 --&gt; 基本类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05ArrayListBasic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; listA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 错误写法！泛型只能是引用类型，不能是基本类型</span></span><br><span class="line"><span class="comment">//        ArrayList&lt;int&gt; listB = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; listC = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        listC.add(<span class="number">100</span>);</span><br><span class="line">        listC.add(<span class="number">200</span>);</span><br><span class="line">        System.out.println(listC); <span class="comment">// [100, 200]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = listC.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"第1号元素是："</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learn java</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始学java-1</title>
    <url>/blog/2019/11/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6java-1/</url>
    <content><![CDATA[<h2 id="命令提示符（cmd-command-）"><a href="#命令提示符（cmd-command-）" class="headerlink" title="命令提示符（cmd(command)）"></a>命令提示符（cmd(command)）</h2><p>启动：win+r</p><p>切换盘符：盘符名称：</p><p>进入文件夹：cd 文件夹名称</p><a id="more"></a>


<p>进入多级文件夹：cd 文件夹1\文件夹2...</p>
<p>后退到根目录：cd \ </p>
<h2 id><a href="#" class="headerlink" title></a></h2><p><strong>JVM</strong>（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 <strong>跨平台</strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系 统上，这个特性称为<strong>Java**</strong>语言的跨平台特性**。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM 运行在操作系统上。 查看文件夹文件列表：dir</p>
<p>清屏：cls</p>
<p>退出：exit</p>
<hr>
<h2 id="Java虚拟机–JVM"><a href="#Java虚拟机–JVM" class="headerlink" title="Java虚拟机–JVM"></a>Java虚拟机–JVM</h2><ul>
<li><strong>JVM</strong>（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 </li>
<li><strong>跨平台</strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系 统上，这个特性称为<strong>Java</strong>语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM 运行在操作系统上。 </li>
</ul>
<p><img src="/blog/imgs/java/jvm.png" alt></p>
<p>如图所示，Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。</p>
<hr>
<h2 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h2><p><strong>JRE</strong> (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。 </p>
<p><strong>JDK</strong> (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 我们想要运行一个已有的Java程序，那么只需安装 JRE 即可。 我们想要开发一个全新的Java程序，那么必须安装 JDK 。 </p>
<p><img src="/blog/imgs/java/jdk2.png" alt></p>
<p><img src="/blog/imgs/java/jdk.png" alt></p>
<p>小贴士： 三者关系： JDK &gt; JRE &gt; JVM </p>
<hr>
<h2 id="环境变量的设置"><a href="#环境变量的设置" class="headerlink" title="环境变量的设置"></a>环境变量的设置</h2><p><img src="/blog/imgs/java/peizhi.png" alt></p>
<p>在系统变量中这样设置即可。</p>
<hr>
<h2 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h2><p>javac编译.java文件生成.class文件</p>
<p>java执行.class文件，但是命令不需要.class后缀</p>
<p><img src="/imgs/java/compile.png" alt></p>
<hr>
<h2 id="常量类型"><a href="#常量类型" class="headerlink" title="常量类型"></a>常量类型</h2><p><img src="/blog/imgs/java/changliang.png" alt></p>
<p><code>&quot;&quot;</code>能输出（空字符串能输出），<code>&#39;&#39;</code>不能输出（不能为空字符，加一个空格则正确）。</p>
<hr>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型<br>    整数型    byte short int long<br>    浮点型    float double<br>    字符型    char<br>    布尔型    boolean</p>
<p>引用数据类型（今后学习）<br>    字符串、数组、类、接口、Lambda</p>
<p>注意事项：</p>
<ol>
<li><p>字符串不是基本类型，而是引用类型。</p>
</li>
<li><p>浮点型可能只是一个近似值，并非精确的值。</p>
</li>
<li><p>数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。</p>
</li>
<li><p>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。<br>如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。</p>
</li>
</ol>
<p>   <strong>四类八种基本数据类型：</strong></p>
<p><img src="/blog/imgs/java/shujuleixing.png" alt></p>
<h5 id="注意变量的作用域"><a href="#注意变量的作用域" class="headerlink" title="注意变量的作用域"></a>注意变量的作用域</h5><p><img src="/blog/imgs/java/zuoyongyu.png" alt></p>
<p>可在{}外定义相同名字的变量</p>
<p><strong>有时候if语句中定义的变量，{}外面不能使用。</strong></p>
<hr>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h4 id="自动类型转换（隐式）"><a href="#自动类型转换（隐式）" class="headerlink" title="自动类型转换（隐式）"></a>自动类型转换（隐式）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当数据类型不一样时，将会发生数据类型转换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">自动类型转换（隐式）</span></span><br><span class="line"><span class="comment">	1. 特点：代码不需要进行特殊处理，自动完成。</span></span><br><span class="line"><span class="comment">	2. 规则：数据范围从小到大。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">强制类型转换（显式）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01DataType</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="number">1024</span>); <span class="comment">// 这就是一个整数，默认就是int类型</span></span><br><span class="line">		System.out.println(<span class="number">3.14</span>); <span class="comment">// 这就是一个浮点数，默认就是double类型</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 左边是long类型，右边是默认的int类型，左右不一样</span></span><br><span class="line">		<span class="comment">// 一个等号代表赋值，将右侧的int常量，交给左侧的long变量进行存储</span></span><br><span class="line">		<span class="comment">// int --&gt; long，符合了数据范围从小到大的要求</span></span><br><span class="line">		<span class="comment">// 这一行代码发生了自动类型转换。</span></span><br><span class="line">		<span class="keyword">long</span> num1 = <span class="number">100</span>;</span><br><span class="line">		System.out.println(num1); <span class="comment">// 100</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 左边是double类型，右边是float类型，左右不一样</span></span><br><span class="line">		<span class="comment">// float --&gt; double，符合从小到大的规则</span></span><br><span class="line">		<span class="comment">// 也发生了自动类型转换</span></span><br><span class="line">		<span class="keyword">double</span> num2 = <span class="number">2.5F</span>;</span><br><span class="line">		System.out.println(num2); <span class="comment">// 2.5</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 左边是float类型，右边是long类型，左右不一样</span></span><br><span class="line">		<span class="comment">// long --&gt; float，范围是float更大一些，符合从小到大的规则</span></span><br><span class="line">		<span class="comment">// 也发生了自动类型转换</span></span><br><span class="line">		<span class="keyword">float</span> num3 = <span class="number">30L</span>;</span><br><span class="line">		System.out.println(num3); <span class="comment">// 30.0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，</span></span><br><span class="line"><span class="comment">那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 如果没有超过左侧的范围，编译器补上强转。</span></span><br><span class="line"><span class="comment">2. 如果右侧超过了左侧范围，那么直接编译器报错。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12Notice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 右侧确实是一个int数字，但是没有超过左侧的范围，就是正确的。</span></span><br><span class="line">		<span class="comment">// int --&gt; byte，不是自动类型转换</span></span><br><span class="line">		<span class="keyword">byte</span> num1 = <span class="comment">/*(byte)*/</span> <span class="number">30</span>; <span class="comment">// 右侧没有超过左侧的范围</span></span><br><span class="line">		System.out.println(num1); <span class="comment">// 30</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// byte num2 = 128; // 右侧超过了左侧的范围</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// int --&gt; char，没有超过范围</span></span><br><span class="line">		<span class="comment">// 编译器将会自动补上一个隐含的(char)</span></span><br><span class="line">		<span class="keyword">char</span> zifu = <span class="comment">/*(char)*/</span> <span class="number">65</span>;</span><br><span class="line">		System.out.println(zifu); <span class="comment">// A</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，</span></span><br><span class="line"><span class="comment">那么编译器javac将会直接将若干个常量表达式计算得到结果。</span></span><br><span class="line"><span class="comment">short result = 5 + 8; // 等号右边全都是常量，没有任何变量参与运算</span></span><br><span class="line"><span class="comment">编译之后，得到的.class字节码文件当中相当于【直接就是】：</span></span><br><span class="line"><span class="comment">short result = 13;</span></span><br><span class="line"><span class="comment">右侧的常量结果数值，没有超过左侧范围，所以正确。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这称为“编译器的常量优化”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo13Notice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">short</span> num1 = <span class="number">10</span>; <span class="comment">// 正确写法，右侧没有超过左侧的范围，</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">short</span> a = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">short</span> b = <span class="number">8</span>;</span><br><span class="line">		<span class="comment">// short + short --&gt; int + int --&gt; int</span></span><br><span class="line">		<span class="comment">// short result = a + b; // 错误写法！左侧需要是int类型</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 右侧不用变量，而是采用常量，而且只有两个常量，没有别人</span></span><br><span class="line">		<span class="keyword">short</span> result = <span class="number">5</span> + <span class="number">8</span>;</span><br><span class="line">		System.out.println(result);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">short</span> result2 = <span class="number">5</span> + a + <span class="number">8</span>; <span class="comment">// 18</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强制类型转换（显式）"><a href="#强制类型转换（显式）" class="headerlink" title="强制类型转换（显式）"></a>强制类型转换（显式）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">强制类型转换</span></span><br><span class="line"><span class="comment">	1. 特点：代码需要进行特殊的格式处理，不能自动完成。</span></span><br><span class="line"><span class="comment">	2. 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">	1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。</span></span><br><span class="line"><span class="comment">	2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”.</span></span><br><span class="line"><span class="comment">	3. byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。</span></span><br><span class="line"><span class="comment">	4. boolean类型不能发生数据类型转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02DataType</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 左边是int类型，右边是long类型，不一样</span></span><br><span class="line">		<span class="comment">// long --&gt; int，不是从小到大</span></span><br><span class="line">		<span class="comment">// 不能发生自动类型转换！</span></span><br><span class="line">		<span class="comment">// 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</span></span><br><span class="line">		<span class="keyword">int</span> num = (<span class="keyword">int</span>) <span class="number">100L</span>;</span><br><span class="line">		System.out.println(num);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// long强制转换成为int类型</span></span><br><span class="line">		<span class="keyword">int</span> num2 = (<span class="keyword">int</span>) <span class="number">6000000000L</span>;</span><br><span class="line">		System.out.println(num2); <span class="comment">// 1705032704</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// double --&gt; int，强制类型转换</span></span><br><span class="line">		<span class="keyword">int</span> num3 = (<span class="keyword">int</span>) <span class="number">3.99</span>;</span><br><span class="line">		System.out.println(num3); <span class="comment">// 3，这并不是四舍五入，所有的小数位都会被舍弃掉</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> zifu1 = <span class="string">'A'</span>; <span class="comment">// 这是一个字符型变量，里面是大写字母A</span></span><br><span class="line">		System.out.println(zifu1 + <span class="number">1</span>); <span class="comment">// 66，也就是大写字母A被当做65进行处理</span></span><br><span class="line">		<span class="comment">// 计算机的底层会用一个数字（二进制）来代表字符A，就是65</span></span><br><span class="line">		<span class="comment">// 一旦char类型进行了数学运算，那么字符就会按照一定的规则翻译成为一个数字</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">byte</span> num4 = <span class="number">40</span>; <span class="comment">// 注意！右侧的数值大小不能超过左侧的类型范围</span></span><br><span class="line">		<span class="keyword">byte</span> num5 = <span class="number">50</span>;</span><br><span class="line">		<span class="comment">// byte + byte --&gt; int + int --&gt; int</span></span><br><span class="line">		<span class="keyword">int</span> result1 = num4 + num5;</span><br><span class="line">		System.out.println(result1); <span class="comment">// 90</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">short</span> num6 = <span class="number">60</span>;</span><br><span class="line">		<span class="comment">// byte + short --&gt; int + int --&gt; int</span></span><br><span class="line">		<span class="comment">// int强制转换为short：注意必须保证逻辑上真实大小本来就没有超过short范围，否则会发生数据溢出</span></span><br><span class="line">		<span class="keyword">short</span> result2 = (<span class="keyword">short</span>) (num4 + num6);</span><br><span class="line">		System.out.println(result2); <span class="comment">// 100</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数字和字符的对照关系表（编码表）：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ASCII码表：American Standard Code for Information Interchange，美国信息交换标准代码。</span></span><br><span class="line"><span class="comment">Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">48 - '0'</span></span><br><span class="line"><span class="comment">65 - 'A'</span></span><br><span class="line"><span class="comment">97 - 'a'</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03DataTypeChar</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span> zifu1 = <span class="string">'1'</span>;</span><br><span class="line">		System.out.println(zifu1 + <span class="number">0</span>); <span class="comment">// 49</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> zifu2 = <span class="string">'A'</span>; <span class="comment">// 其实底层保存的是65数字</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> zifu3 = <span class="string">'c'</span>;</span><br><span class="line">		<span class="comment">// 左侧是int类型，右边是char类型，</span></span><br><span class="line">		<span class="comment">// char --&gt; int，确实是从小到大</span></span><br><span class="line">		<span class="comment">// 发生了自动类型转换</span></span><br><span class="line">		<span class="keyword">int</span> num = zifu3;</span><br><span class="line">		System.out.println(num); <span class="comment">// 99</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> zifu4 = <span class="string">'中'</span>; <span class="comment">// 正确写法</span></span><br><span class="line">		System.out.println(zifu4 + <span class="number">0</span>); <span class="comment">// 20013</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加法的用法"><a href="#加法的用法" class="headerlink" title="加法的用法"></a>加法的用法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">四则运算当中的加号“+”有常见的三种用法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 对于数值来说，那就是加法。</span></span><br><span class="line"><span class="comment">2. 对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算。</span></span><br><span class="line"><span class="comment">char类型字符，和int类型数字，之间的对照关系表：ASCII、Unicode</span></span><br><span class="line"><span class="comment">3. 对于字符串String（首字母大写，并不是关键字）来说，加号代表字符串连接操作。</span></span><br><span class="line"><span class="comment">任何数据类型和字符串进行连接的时候，结果都会变成字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Plus</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 字符串类型的变量基本使用</span></span><br><span class="line">		<span class="comment">// 数据类型 变量名称 = 数据值;</span></span><br><span class="line">		String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">		System.out.println(str1); <span class="comment">// Hello</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"Hello"</span> + <span class="string">"World"</span>); <span class="comment">// HelloWorld</span></span><br><span class="line">		</span><br><span class="line">		String str2 = <span class="string">"Java"</span>;</span><br><span class="line">		<span class="comment">// String + int --&gt; String</span></span><br><span class="line">		System.out.println(str2 + <span class="number">20</span>); <span class="comment">// Java20</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 优先级问题</span></span><br><span class="line">		<span class="comment">// String + int + int</span></span><br><span class="line">		<span class="comment">// String		+ int</span></span><br><span class="line">		<span class="comment">// String</span></span><br><span class="line">		System.out.println(str2 + <span class="number">20</span> + <span class="number">30</span>); <span class="comment">// Java2030</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(str2 + (<span class="number">20</span> + <span class="number">30</span>)); <span class="comment">// Java50</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch的一些注意事项"><a href="#switch的一些注意事项" class="headerlink" title="switch的一些注意事项"></a>switch的一些注意事项</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">switch语句使用的注意事项：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 多个case后面的数值不可以重复。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. switch后面小括号当中只能是下列数据类型：</span></span><br><span class="line"><span class="comment">基本数据类型：byte/short/char/int</span></span><br><span class="line"><span class="comment">引用数据类型：String字符串、enum枚举</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。</span></span><br><span class="line"><span class="comment">“匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者整体结束为止。”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08SwitchNotice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">switch</span> (num) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				System.out.println(<span class="string">"你好"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				System.out.println(<span class="string">"我好"</span>);</span><br><span class="line">				<span class="comment">// break;</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				System.out.println(<span class="string">"大家好"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				System.out.println(<span class="string">"他好，我也好。"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="comment">// switch</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learn java</category>
      </categories>
  </entry>
  <entry>
    <title>algorithm-7</title>
    <url>/blog/2019/11/19/algorithm-7/</url>
    <content><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p> 有许多问题，当需要找出它的解集或者要求在某些约束条件下的最优解时，往往可以采用回溯法。</p><p>回溯法的基本做法是<em>搜索</em>，它是一种可以<em>避免不必要搜索的穷举式搜索法</em>。</p><a id="more"></a>

<p>回溯法适合求解一些<em>组合数较大</em>的问题。</p>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li><p>回溯法在问题的解空间树中，按深度优先策略，从根节点出发搜索解空间树。</p>
</li>
<li><p>算法搜索至解空间树的任意一点时，先判断该节点是否包含问题的解。</p>
<ul>
<li>如果肯定不包含，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯。</li>
</ul>
</li>
<li><p>否则进入该子树，继续按深度优先策略搜索</p>
</li>
</ul>
<h4 id="生成问题状态的说明"><a href="#生成问题状态的说明" class="headerlink" title="生成问题状态的说明"></a>生成问题状态的说明</h4><ul>
<li>扩展节点：一个正在产生儿子的节点成为扩展节点。</li>
<li>活节点：一个自身已生成但其儿子还没有全部生成的节点称作活节点。</li>
<li>死节点：一个所有儿子已经产生的节点成为死节点。</li>
</ul>
<h4 id="生成问题状态的基本方法"><a href="#生成问题状态的基本方法" class="headerlink" title="生成问题状态的基本方法"></a>生成问题状态的基本方法</h4><p>回溯法：为了避免生成那些不可能产生最优解的问题状态，要不断得利用限界函数（bounding function）来“处死”那些实际上不可能产生所需解的活节点，从而减少问题的计算量。<em>具有限界函数的深度优先生成法</em>称为回溯法。</p>
<h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol>
<li>针对所给问题，定义问题的解空间。</li>
<li>确定易于搜索的解空间结构。</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h6 id="常用剪枝函数"><a href="#常用剪枝函数" class="headerlink" title="常用剪枝函数"></a>常用剪枝函数</h6><ul>
<li>用约束函数在扩展节点处剪去不满足约束的子树。</li>
<li>用限界函数剪去得不到最优解的子树。</li>
</ul>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p>在搜索至树上任意一点时，先判断该节点对应部分解是否满足约束条件，或是否超过目标函数的界。</p>
<ul>
<li>判断该节点是否包含问题的（最优）解<ul>
<li>不包含，则跳过对以该节点为根的子树的搜索，剪枝（pruning）。 </li>
<li>包含，则进入以该节点为根的子树，继续按深度优先搜索。</li>
</ul>
</li>
</ul>
<h4 id="回溯法求解时常见的两类解空间树"><a href="#回溯法求解时常见的两类解空间树" class="headerlink" title="回溯法求解时常见的两类解空间树"></a>回溯法求解时常见的两类解空间树</h4><h5 id="子集树："><a href="#子集树：" class="headerlink" title="子集树："></a>子集树：</h5><p>类似于01背包的，每件物品可取可不取的树。P115</p>
<h5 id="排列树："><a href="#排列树：" class="headerlink" title="排列树："></a>排列树：</h5><p>类似于tsp问题的，总数为n！的树。P116</p>
<p>​                       </p>
<h1 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h1><p>类似于回溯法，是在问题的解空间树上搜索问题解的答案。</p>
<p>不同点：</p>
<ul>
<li>求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有借，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出某种意义下的最优解。</li>
<li>搜索方式的不同：回溯法以<strong><em>深度优先</em></strong>的方式搜索解空间树，而分支限界法以<strong>广度优先</strong>或以<strong>最小耗费优先</strong>的方式搜索解空间树。</li>
</ul>
<h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>分支限界法常以广度优先或以最小耗费（最大收益）优先的方式搜索问题的解空间树。</p>
<ul>
<li>在分支限界法中，每一个活节点只有一次机会成为扩展节点。活节点一旦成为扩展节点，就一次性产生其所有儿子节点。在这些儿子节点中，导致不可行解或导致非最优解的儿子节点被舍弃，其余儿子节点被加入活结点表中。</li>
<li>此后，从活节点表中取下一节点成为当前扩展节点，并重复上述节点扩展过程。这个郭晨肝移植持续到找到所需的解或者活结点表为空为止。</li>
</ul>
<h4 id="常见的两种分支限界法"><a href="#常见的两种分支限界法" class="headerlink" title="常见的两种分支限界法"></a>常见的两种分支限界法</h4><h5 id="队列式（FIFO）分支限界法"><a href="#队列式（FIFO）分支限界法" class="headerlink" title="队列式（FIFO）分支限界法"></a>队列式（FIFO）分支限界法</h5><p>按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。</p>
<h5 id="优先队列式分支限界法"><a href="#优先队列式分支限界法" class="headerlink" title="优先队列式分支限界法"></a>优先队列式分支限界法</h5><ul>
<li>按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</li>
<li>应用优先队列式分支限界法求解具体问题时，应该根据具体问题的特点确定选用最大优先队列活着最小优先队列表示解空间的活结点表。</li>
</ul>
]]></content>
      <categories>
        <category>learn algorithm</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
        <tag>分支限界法</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-6</title>
    <url>/blog/2019/11/19/algorithm-6/</url>
    <content><![CDATA[<h1 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h1><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><h5 id="随机序列"><a href="#随机序列" class="headerlink" title="随机序列"></a>随机序列</h5><ul>
<li>概率相等（均匀随机）</li>
<li>不可预测</li>
<li>不可重现</li>
</ul><ul>
<li>目前的计算机中，无法产生真正的随机数，因此在随机算法中使用的随机数 都是一定程度上随机的，即伪随机数。</li>
<li>产生伪随机数的方法：线性同余法……</li>
</ul><a id="more"></a>

<h4 id="确定性算法"><a href="#确定性算法" class="headerlink" title="确定性算法"></a>确定性算法</h4><p>输入确定，则对这个特定输入的每次运行过程是可重复的，运行结果是一样的。</p>
<p>比如，对于输入&lt;6,4,5,8,9,3&gt;，正确的插入排序算法对于这个输入，每次的运行过程是一样的，运行结果也是一样的。</p>
<h4 id="随机算法的基本思想"><a href="#随机算法的基本思想" class="headerlink" title="随机算法的基本思想"></a>随机算法的基本思想</h4><ul>
<li><p>Randomized Algorithms(随机算法)</p>
</li>
<li><p>Probabilistic Algorithms概率算法）</p>
</li>
<li><p>引入了随机因素</p>
</li>
<li><p>在随机算法中</p>
<ul>
<li><p>不要求算法对于所有可能的输入均正确计算</p>
<ul>
<li>只要求出现错误的可能性晓得可以忽略的程度。</li>
</ul>
</li>
</ul>
</li>
<li><p>另外也不要求对同一输入，算法每次执行时给出相同的结果。</p>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>有不少问题，目前只有效率很差的确定性求解算法，但用随机算法去求解，可以很快的获得相当可信的结果。</p>
<h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><ul>
<li>随机算法在分布式计算、通信、信息检索、计算几何、密码学等血多领域都有着广泛的应用。</li>
<li>最著名的是在公开密钥体系、RSA算法方面的应用。</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>通常可以分为两类</p>
<ul>
<li>Las Vegas算法</li>
<li>Monte Carlo算法</li>
</ul>
<h4 id="Las-Vegas算法"><a href="#Las-Vegas算法" class="headerlink" title="Las Vegas算法"></a>Las Vegas算法</h4><ul>
<li>在少数应用中，可能出现求不出解的情况。</li>
<li>但一旦找到一个解，这个解一定是正确的。</li>
<li>再求不出来解时，需要再次调用算法进行计算，直到获得解为止。</li>
<li>对于此类算法，主要是分析算法的时间复杂度的期望值，以及调用一次产生失败（求不出解）的概率。</li>
</ul>
<h5 id="举例：找第k小元素的随机算法"><a href="#举例：找第k小元素的随机算法" class="headerlink" title="举例：找第k小元素的随机算法"></a>举例：找第k小元素的随机算法</h5><h4 id="Monte-Carlo算法"><a href="#Monte-Carlo算法" class="headerlink" title="Monte Carlo算法"></a>Monte Carlo算法</h4><ul>
<li>通常不能保证计算出来的结果总是正确的，一般只能判定所给解的正确性不小于p（1/2&lt;p&lt;1）</li>
<li>通过算法的反腐执行（即以增大算法的执行时间为代价），能够使发生错误的概率小到可以忽略的程度。</li>
<li>由于每次执行的算法是独立的，故k次执行均发生错误的概率为（1-p）^k。</li>
<li>对于判定问题（回答只能是“Yes”或“No”）<ul>
<li>带双错的(two-sided error)：回答“Yes”或“No”都有可能错。</li>
<li>带单错的(one-sided error)：只有一种回答可能错。</li>
</ul>
</li>
<li>Las Vegas算法可以看成是单错概率为0的Monte Carlo算法。</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>在不允许发生错误的应用中（人造飞船、电网控制等），Monte Carlo算法不可以使用</li>
<li>若以小概率的出错允许的话，Monte Carlo算法比Las Vegas算法要节省许多时间，所以经常被采用。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>对于某一给定的问题，随机算法所需的时间和空间复杂性，往往比当前的已知的、最好的确定性算法要好。</li>
<li>到目前为止设计出来的各种随机算法，无论是理解上还是实现上，都是极为简单的。</li>
<li>随机算法避免了去构造最坏情况的例子。</li>
</ul>
<h5 id="举例：Testing-String-Equality"><a href="#举例：Testing-String-Equality" class="headerlink" title="举例：Testing String Equality"></a>举例：Testing String Equality</h5><h4 id="Sherwood随机化方法（属Las-Vegas算法）"><a href="#Sherwood随机化方法（属Las-Vegas算法）" class="headerlink" title="Sherwood随机化方法（属Las Vegas算法）"></a>Sherwood随机化方法（属Las Vegas算法）</h4><ul>
<li>如果某个问题已经有了一个平均情况下较好的确定性算法，但是该算法在最坏情况下效率不高，此时<em>引入一个随机数发生器</em>（通常是服从均匀分布，根据问题需要也可以产生其他的分布），可将一个确定性算法改成一个随机算法，使得对于任何输入实例，该算法在概率意义下都有很好的性能。（Select，QuickSort）</li>
<li>如果算法（所给的确定性算法）无法直接使用Sherwood方法，则可以<em>采用随机预处理的方法，使得输入对象服从均匀分布</em>（或其他分布），然后再用确定性算法对其进行处理。所得效果在概率意义下与Sherwood型算法相同。</li>
<li>Sherwood算法总能求得问题的一个解，且所求得的解一定是正确的。</li>
<li>当一个确定性算法在最坏情况和平均情况下的时间复杂度有较大差别时，可在确定性算法中引入随机性将其改造为Sherwood算法，以消除或减少问题的好坏输入实例间的差别。</li>
</ul>
]]></content>
      <categories>
        <category>learn algorithm</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-5</title>
    <url>/blog/2019/11/18/algorithm-5/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>适用于求解最优化问题的算法往往包含一系列步骤，每一步都有一组选择。</li>
<li>贪心算法总是作出在当前看来是最好的选择。</li>
<li>贪心算法并不从整体最优上加以考虑，他所作出的选择只是在某种意义上的局部最优选择。</li>
<li>贪心算法不能对所有问题都得到整体最优解，但对许多问题他能产生整体最优解。</li>
<li>在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</li>
<li>与动态规划方法相比，贪心算法更简单，更直接。</li>
</ul><a id="more"></a>
<h4 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h4><ol>
<li>最优子结构性质</li>
<li>贪心选择性质：贪心算法通过做一系列的选择来给出某一问题的最优解。他所作出的每一个选择当前状态下的最好选择（局部），即贪心选择。</li>
</ol>
<h4 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h4><ul>
<li>是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。</li>
<li>这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</li>
<li>动态规划算法通常以自底向上的方式解决各子问题。</li>
<li>贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每做一次贪心选择就将所求问题简化为规模更小的子问题。</li>
</ul>
<h4 id="重要实例"><a href="#重要实例" class="headerlink" title="重要实例"></a>重要实例</h4><ul>
<li><p>单源最短路径</p>
<p> <code>Dijkstra算法</code></p>
</li>
<li><p>最小生成树</p>
<p> <code>Prim算法</code> <code>Kruskal算法</code></p>
</li>
<li><p>哈弗曼编码</p>
</li>
</ul>
]]></content>
      <categories>
        <category>learn algorithm</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-4</title>
    <url>/blog/2019/11/18/algorithm-4/</url>
    <content><![CDATA[<h1 id="动态规划（dynamic-programing）"><a href="#动态规划（dynamic-programing）" class="headerlink" title="动态规划（dynamic programing）"></a>动态规划（dynamic programing）</h1><h4 id="分治法求解"><a href="#分治法求解" class="headerlink" title="分治法求解"></a>分治法求解</h4><p>子问题相互独立，不包含公共子问题。</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul>
<li>与分治法类似，也是将问题分解为规模逐渐减小的同类型的子问题。</li>
<li>与分治法不同的是，分解得到的子问题往往不是互相独立的。</li>
</ul><a id="more"></a>

<h4 id="相关的重要概念"><a href="#相关的重要概念" class="headerlink" title="相关的重要概念"></a>相关的重要概念</h4><ul>
<li>子问题的高度重复性</li>
<li>最优子结构性质：问题的最优解中包含着其中每一个子问题的最优解。</li>
</ul>
<h4 id="适用于用动态规划解决的问题"><a href="#适用于用动态规划解决的问题" class="headerlink" title="适用于用动态规划解决的问题"></a>适用于用动态规划解决的问题</h4><ul>
<li>若一个问题可以分解为若干个高度重复的子问题，且问题也具有组柚子结构性质，就可用动态规划进行求解。</li>
<li>具体方式：可以地推的方式逐层计算最优值并记录必要的信息，最后根据记录的信息构造最优解。</li>
</ul>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>用一个表来记录所有已解决的子问题的答案，不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。（保存已解决的子问题的答案，在需要时使用，从而避免大量重复计算）</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>找出最优解的性质，并刻画其结构特征。</li>
<li>递归的定义最优值。</li>
<li>以自底向上的方式计算最优值。</li>
<li>根据计算最优值时得到的信息，构造最优解。</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//暴力法 O(n^3)</span><br><span class="line">public static int get_smallest_sum(int[] a) &#123;</span><br><span class="line">		int max_sum = 0, current_sum = 0;</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			for (int j = i + 1; j &lt; a.length; j++) &#123;</span><br><span class="line">				current_sum = 0;</span><br><span class="line">				for (int k = i; k &lt; j; k++) &#123;//从i+到j，用k遍历</span><br><span class="line">					current_sum += a[k];</span><br><span class="line">					if (current_sum &gt; max_sum)</span><br><span class="line">						max_sum = current_sum;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return max_sum;</span><br><span class="line">	&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//暴力法 O(n^2)</span><br><span class="line">public static int get_smallest_sum(int[] a) &#123;</span><br><span class="line">		int max_sum = 0, current_sum = 0, len = 0;</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			current_sum = a[i];</span><br><span class="line">			for (int j = i + 1; j &lt; a.length; j++) &#123;//从i开始往后面加，遍历往后加的个数</span><br><span class="line">				current_sum += a[j];</span><br><span class="line">				if (current_sum &gt; max_sum)</span><br><span class="line">					max_sum = current_sum;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		return max_sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//动态规划 取（当前和+当前值）（当前值）的较大值作为更新后的当前较大和</span><br><span class="line">//currentSum[i]=max&#123;currentSum[i-1],arr[i]&#125;</span><br><span class="line">public static int maxSum(int[] arr) &#123;</span><br><span class="line">	int sum = 0, currentSum = 0;</span><br><span class="line">	for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">		currentSum = ((currentSum + arr[i]) &gt; arr[i]) ? currentSum + arr[i] : arr[i];</span><br><span class="line">		if (currentSum &gt; sum) &#123;</span><br><span class="line">			sum = currentSum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learn algorithm</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-3</title>
    <url>/blog/2019/11/17/algorithm-3/</url>
    <content><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>递归函数：用函数自身给出定义的函数</li>
<li>递归算法：一个算法包含对自身的调用，这种调用可以是直接的，也可以是间接地。</li>
</ul><a id="more"></a>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="阶乘函数"><a href="#阶乘函数" class="headerlink" title="阶乘函数"></a>阶乘函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int factorial(int n)&#123;</span><br><span class="line">		if(n==0) return 1;</span><br><span class="line">		else</span><br><span class="line">			return factorial(n-1)*n;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Fibonacci数列"><a href="#Fibonacci数列" class="headerlink" title="Fibonacci数列"></a>Fibonacci数列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int fibonacci(int n)&#123;</span><br><span class="line">		if(n==1||n==2) return 1;</span><br><span class="line">		else</span><br><span class="line">			return fibonacci(n-1)+fibonacci(n-2);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a>整数划分问题</h5><p>将正整数n表示成一系列正整数之和：<strong>n=n1+n2+…+nk</strong>，其中<strong>n1</strong>≥n2≥…≥nk≥1，k≥1。<br>正整数n的这种表示称为正整数n的划分。求正整数n的不同划分个数。<br>例如：正整数6有如下11种不同的划分：<br>6；<br>5+1；<br>4+2，4+1+1；<br>3+3，3+2+1，3+1+1+1；<br>2+2+2，2+2+1+1，2+1+1+1+1；<br>1+1+1+1+1+1。</p>
<p>一些经典的递归问题（阶乘，斐波那契），问题本身都具有比较明显的递归关系，因而容易用递归函数直接求解。</p>
<p>在本例中，如果设p(n)为正整数n的划分数，则难以找到递归关系，因此考虑增加一个自变量：将<strong>最大加数n1不大于m的划分个数记作q(n,m)</strong>。可以建立q(n,m)的如下递归关系。（若不理解加粗部分，建议把题目多读几遍）</p>
<p>(1) q(n,1)=1, n≥1; 当最大加数n1不大于1时，任何正整数n只有一种划分形式， 即n=1+1+…+1(n个1)</p>
<p>(2) q(n,m)=q(n,n), m ≥ n;<br>最大加数n1实际上不能大于n。因此，q(1,m)=1。</p>
<p>(3) q(n,n)=1+q(n,n-1);<br>正整数n的划分由n1=n的划分和n1 ≤ n-1的划分组成。</p>
<p>(4) q(n,m)=q(n,m-1)+q(n-m,m), n＞m＞ 1;<br>正整数n的最大加数n1不大于m的划分，由n1≤ m-1 的划分和n1=m的划分组成。n1=m 的划分就是该划分中必然包含数m，因此其划分的数目与n-m的m划分一致。</p>
<p>如果设p(n)为正整数n的划分数，则难以找到递归关系，因此考虑增加一个自变量：将最大加数n1不大于m的划分个数记作q(n,m)。可以建立q(n,m)的如下递归关系。（正整数n的划分数p(n)=q(n,n)。 ）</p>
<h6 id="q-n-m-q-当前需要被划分的数字，划分中的加数的最大取值"><a href="#q-n-m-q-当前需要被划分的数字，划分中的加数的最大取值" class="headerlink" title="q(n,m)=q(当前需要被划分的数字，划分中的加数的最大取值)"></a>q(n,m)=q(当前需要被划分的数字，划分中的加数的最大取值)</h6><p><img src="/imgs/algorithm/integerdiv.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int q(int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    if((n &lt; 1) || (m &lt; 1)) //无意义情况 </span><br><span class="line">        return 0;</span><br><span class="line">    if((n == 1) || (m == 1))//数字1，划分最大加数为1的划分只会有1种 </span><br><span class="line">        return 1;</span><br><span class="line">    if(n &lt; m)			   //需要划分的数字n，实际情况不会小于其划分最大加数 </span><br><span class="line">        return q(n, n);</span><br><span class="line">    if(n == m)				//正整数n的划分由n1=n的划分和n1 ≤ n-1的划分组成。 </span><br><span class="line">        return q(n, m - 1) + 1;</span><br><span class="line">    return q(n, m - 1) + q(n - m, m);//被划分数为n，最大划分加数为m的划分数目，等于， </span><br><span class="line">	// 被划分数为n最大加数为m-1的划分数目 + 被划分数为（n-m）最大加数为m的划分数目   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int	main()</span><br><span class="line">&#123;</span><br><span class="line">    int	m = 6, n = 6;</span><br><span class="line">    for(int i=1;i&lt;=6;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	cout &lt;&lt;&quot;  数字为&quot;&lt;&lt;n&lt;&lt;&quot;时，最大划分加数上限为&quot;&lt;&lt;i&lt;&lt;&quot;时的划分情况有&quot;&lt;&lt; q(n, i) &lt;&lt;&quot;种&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归的优点"><a href="#递归的优点" class="headerlink" title="递归的优点"></a>递归的优点</h4><p>结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，为设计算法、调试程序提供了很大的便利。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>递归算法的运行效率较低，生成的子递归多有重复。</p>
<h4 id="递归式的解法："><a href="#递归式的解法：" class="headerlink" title="递归式的解法："></a>递归式的解法：</h4><ul>
<li>代换法（substitution method）：猜测解并用数学归纳法证明。</li>
<li>递归树方法（recursion-tree method）</li>
<li>主方法（master method）</li>
</ul>
<h5 id="递归树"><a href="#递归树" class="headerlink" title="递归树"></a>递归树</h5><p>学习 <a href="https://blog.csdn.net/every__day/article/details/86554857" target="_blank" rel="noopener">https://blog.csdn.net/every__day/article/details/86554857</a> </p>
<h5 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h5><p>学习 <a href="https://blog.csdn.net/jal517486222/article/details/82805401" target="_blank" rel="noopener">https://blog.csdn.net/jal517486222/article/details/82805401</a> </p>
<ul>
<li>值得注意的是，这三种情况并没有覆盖所有的<code>f（n）</code>，应用时需要注意是否符合这三种情况。</li>
</ul>
<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h4 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h4><ul>
<li>分解（Divide）：将原问题分解为子问题</li>
<li>解决（Conquer）：求解子问题</li>
<li>合并（Combine）：组合子问题的解得到原问题的解。</li>
</ul>
<h4 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h4><ul>
<li>问题的规模缩小到一定程度就可以容易地解决。</li>
<li>问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>基于子问题的解可以合并为原问题的解。</li>
<li>问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li>
</ul>
<h4 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h4><ul>
<li><p>使子问题规模尽量接近的做法，就是平衡。</p>
</li>
<li><p>在使用分治法和递归时，要尽量把问题分成规模相等，或至少是规模相近的子问题以提高算法的效率。</p>
</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort(int arr[])&#123;</span><br><span class="line">		if(arr ==null||arr.length&lt;=1) return;//数组为空或长度小于一，不用操作</span><br><span class="line">		quickSort(arr,0,arr.length);//注意右端口为数组长度，直接arr[right]会越界</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void quickSort(int arr[],int left,int right)&#123;</span><br><span class="line">		if (right - left &lt;= 1)    return;//递归的终止条件</span><br><span class="line">		int part = partition(arr,left,right);//得到坑值该在的位置</span><br><span class="line">		quickSort(arr, left, part);//左右分别排序</span><br><span class="line">		quickSort(arr, part+1, right);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    private static int partition(int[] arr, int low, int high) &#123;</span><br><span class="line">    	int pivot = arr[low];//一开始确定坑值和坑的位置。</span><br><span class="line">    	int left = low;</span><br><span class="line">    	int right=high-1;//解决数组长度越界</span><br><span class="line">    	while(left&lt;right)&#123;</span><br><span class="line">    		while(left&lt;right&amp;&amp;pivot&lt;=arr[right])</span><br><span class="line">    			--right;//从右边开始找，找到第一个比pivot值小的值</span><br><span class="line">    		arr[left]=arr[right];//把这个第一个比pivot值小的值放到左边</span><br><span class="line">    		while(left&lt;right&amp;&amp;pivot&gt;=arr[left])</span><br><span class="line">    			++left;//从左边开始找，找到第一个比pivot值大的值</span><br><span class="line">    		arr[right]=arr[left];//把这个第一个比pivot值大的值放到右边</span><br><span class="line">    	&#125;</span><br><span class="line">    	arr[left]=pivot;//把开始的坑值填到后面的坑，这里left=right，都可以</span><br><span class="line">    	print(arr);</span><br><span class="line">		return left;//返回坑所在的位置</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learn_algorithm</category>
      </categories>
      <tags>
        <tag>递归与分治</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-2</title>
    <url>/blog/2019/11/17/algorithm-2/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int[] insertSort(int[] a) &#123;</span><br><span class="line">	int j, t;</span><br><span class="line">	for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">		for (j = 0; j &lt; i; j++) &#123;</span><br><span class="line">			if (a[j] &gt; a[i])</span><br><span class="line">				break;//找到第一个前面的大于后面的</span><br><span class="line">		&#125;</span><br><span class="line">		t = a[i];//保存后面的</span><br><span class="line">		for (int k = i - 1; k &gt;= j; k--) &#123;</span><br><span class="line">			a[k + 1] = a[k];//全部后移一位</span><br><span class="line">		&#125;</span><br><span class="line">		a[j] = t;//把后面的值放到前面    2 4 5 0-&gt; 2 4 5 后移一位保存t=0，把第一个位置等于t-&gt;0 2 4 5</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>

<ul>
<li>最好情况运行时间：输入数组已经排好序</li>
<li>最好情况运行时间：问题要求最终按照递增的顺序排序但输入数组是递减排序。</li>
</ul>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>分而治之(divide - conquer);每个递归过程涉及三个步骤<br>第一, 分解: 把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素.<br>第二, 治理: 对每个子序列分别调用归并排序MergeSort, 进行递归操作<br>第三, 合并: 合并两个排好序的子序列,生成排序结果. </p>
<p><img src="/imgs/algorithm/merge.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int[] sort(int[] a,int low,int high)&#123;</span><br><span class="line">        int mid = (low+high)/2;</span><br><span class="line">        if(low&lt;high)&#123;</span><br><span class="line">            sort(a,low,mid);</span><br><span class="line">            sort(a,mid+1,high);</span><br><span class="line">            //左右归并</span><br><span class="line">            merge(a,low,mid,high);</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void merge(int[] a, int low, int mid, int high) &#123;</span><br><span class="line">        int[] temp = new int[high-low+1];</span><br><span class="line">        int i= low;</span><br><span class="line">        int j = mid+1;</span><br><span class="line">        int k=0;</span><br><span class="line">        // 把较小的数先移到新数组中</span><br><span class="line">        while(i&lt;=mid &amp;&amp; j&lt;=high)&#123;</span><br><span class="line">            if(a[i]&lt;a[j])&#123;</span><br><span class="line">                temp[k++] = a[i++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 把左边剩余的数移入数组 </span><br><span class="line">        while(i&lt;=mid)&#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把右边边剩余的数移入数组</span><br><span class="line">        while(j&lt;=high)&#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把新数组中的数覆盖nums数组</span><br><span class="line">        for(int x=0;x&lt;temp.length;x++)&#123;</span><br><span class="line">            a[x+low] = temp[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p><strong>（1）稳定性</strong><br>   　归并排序是一种稳定的排序。<br><strong>（2）存储结构要求</strong><br>  　可用顺序存储结构。也易于在链表上实现。<br><strong>（3）时间复杂度</strong><br>  　对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。<br><strong>（4）空间复杂度</strong><br>   需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。<br> 注意：<br>  　若用单链表做存储结构，很容易给出就地的归并排序</p>
]]></content>
      <categories>
        <category>learn_algorithm</category>
      </categories>
      <tags>
        <tag>InsertSort</tag>
        <tag>MergeSort</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-1</title>
    <url>/blog/2019/11/17/algorithm-1/</url>
    <content><![CDATA[<h1 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h1><h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><p>通俗地讲，算法是指解决问题的一种方法或一个过程。更严格地讲，算法是由若干条指令组成的有穷序列，且满足下述四条性质。</p><a id="more"></a>
<ol>
<li>输入：有零个或多个由外部提供的量作为算法的输入。</li>
<li>输出：算法产生至少一个量作为输出。</li>
<li>确定性：组成算法的每条指令是清晰的，无歧义的。</li>
<li>有限性：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的。</li>
</ol>
<p>有的定义是这样的</p>
<ol>
<li>确定性：每条指令都是明确的、无二义的。</li>
<li>能行性：每条指令都必须是能够执行的。</li>
<li>输入：允许有0个或多个输入量，曲子特定的集合。</li>
<li>输出：产生一个或多个输出，它们与输入量之间存在着某种特定的关系。</li>
<li>有穷性：每条指令执行的次数都是有穷的。</li>
</ol>
<h3 id="算法定义上的解释"><a href="#算法定义上的解释" class="headerlink" title="算法定义上的解释"></a>算法定义上的解释</h3><ul>
<li>有穷指令序列若满足上述五条，即确定性、能行性、输入、输出和有穷性，则通常称之为算法。</li>
<li>若满足前四条而不满足第五条（有穷性）的有穷指令序列通常称之为计算过程。</li>
<li>只要不停电、机器不坏，计算过程就可以永远执行下去（死循环）。</li>
<li>永远执行的计算过程并非毫无用处——OS就是计算过程。</li>
</ul>
<h2 id="算法的“好坏”如何衡量"><a href="#算法的“好坏”如何衡量" class="headerlink" title="算法的“好坏”如何衡量"></a>算法的“好坏”如何衡量</h2><p>算法复杂性的高低体现在运行该算法所需要的计算机资源上，所需资源越多，该算法的复杂性越高；反之，所需资源越少，该算法的复杂性越低。对计算机资源，最重要的是时间和空间（即存储器）资源。因此，算法的复杂性有时间复杂度和空间复杂度之分。</p>
<h2 id="描述算法时间复杂度"><a href="#描述算法时间复杂度" class="headerlink" title="描述算法时间复杂度"></a>描述算法时间复杂度</h2><ul>
<li><p>用问题规模的某个函数来表示算法的基本运算量，这个表示基本运算量的函数称之为算法的时间复杂度。</p>
</li>
<li><p>时间复杂度用<code>T(n)</code>（或<code>T(n,m)</code>）表示</p>
<p>​    <code>T(n)=5n</code></p>
<p>​    <code>T(n)=3nlogn</code></p>
<p>   <code>T(n)=2^n</code></p>
</li>
</ul>
<h3 id="表示渐进表示算法复杂度的符号：O、Ω、θ。"><a href="#表示渐进表示算法复杂度的符号：O、Ω、θ。" class="headerlink" title="表示渐进表示算法复杂度的符号：O、Ω、θ。"></a>表示渐进表示算法复杂度的符号：<code>O</code>、<code>Ω</code>、<code>θ</code>。</h3><p><code>O</code>表示上界，可以理解为<code>≤</code>，<code>Ω</code>表示下界，可以理解为<code>≥</code> ，而<code>θ</code> 既表示上界，也表示下界，所以可以理解为确界。需要补充的是，小写的<code>o</code>表示上界，理解为<code>＜</code>，小写的<code>w</code>表示下界，理解为<code>＞</code>。</p>
<p>举例：<br>$$<br>T(n)=n^3+n^2<br>$$<br>用大O表示法的时间复杂度为<code>O（n^3</code>）,<code>O(n^4)</code>  ……</p>
<p>用Ω表示法的时间复杂度为<code>Ω(n^3)</code>,<code>Ω（n^2））</code>，<code>Ω（n）</code>  ……</p>
<p>用θ表示法的时间复杂度为<code>θ(n^3)</code></p>
]]></content>
      <categories>
        <category>learn_algorithm</category>
      </categories>
      <tags>
        <tag>算法定义</tag>
      </tags>
  </entry>
  <entry>
    <title>学习设计模式-1</title>
    <url>/blog/2019/11/16/designPattern-1/</url>
    <content><![CDATA[<h1 id="实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。"><a href="#实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。" class="headerlink" title="实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。"></a>实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//最原始的做法</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(&quot;请输入数字A：&quot;);</span><br><span class="line">        string A = Console.ReadLine();</span><br><span class="line">        Console.Write(&quot;请选择运算符号(+、-、*、/)：&quot;);</span><br><span class="line">        string B = Console.ReadLine();</span><br><span class="line">        Console.Write(&quot;请输入数字B：&quot;);</span><br><span class="line">        string C = Console.ReadLine();</span><br><span class="line">        string D = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        if (B == &quot;+&quot;)</span><br><span class="line">            D = Convert.ToString(Convert.ToDouble(A) + Convert.ToDouble(C));</span><br><span class="line">        if (B == &quot;-&quot;)</span><br><span class="line">            D = Convert.ToString(Convert.ToDouble(A) - Convert.ToDouble(C));</span><br><span class="line">        if (B == &quot;*&quot;)</span><br><span class="line">            D = Convert.ToString(Convert.ToDouble(A) * Convert.ToDouble(C));</span><br><span class="line">        if (O == &quot;/&quot;)</span><br><span class="line">            D = Convert.ToString(Convert.ToDouble(A) / Convert.ToDouble(C));</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(&quot;结果是：&quot; + D);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//变量名规范以及捕获异常后</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(&quot;请输入数字A：&quot;);</span><br><span class="line">            string strNumberA = Console.ReadLine();</span><br><span class="line">            Console.Write(&quot;请选择运算符号(+、-、*、/)：&quot;);</span><br><span class="line">            string strOperate = Console.ReadLine();</span><br><span class="line">            Console.Write(&quot;请输入数字B：&quot;);</span><br><span class="line">            string strNumberB = Console.ReadLine();</span><br><span class="line">            string strResult = &quot;&quot;;</span><br><span class="line">            switch (strOperate)</span><br><span class="line">            &#123;</span><br><span class="line">                case &quot;+&quot;:</span><br><span class="line">                    strResult = Convert.ToString(Convert.ToDouble(strNumberA) </span><br><span class="line">                        + Convert.ToDouble(strNumberB));</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;-&quot;:</span><br><span class="line">                    strResult = Convert.ToString(Convert.ToDouble(strNumberA) </span><br><span class="line">                        - Convert.ToDouble(strNumberB));</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;*&quot;:</span><br><span class="line">                    strResult = Convert.ToString(Convert.ToDouble(strNumberA) </span><br><span class="line">                        * Convert.ToDouble(strNumberB));</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;/&quot;:</span><br><span class="line">                    if (strNumberB != &quot;0&quot;)</span><br><span class="line">                        strResult = Convert.ToString(Convert.ToDouble(strNumberA) </span><br><span class="line">                              / Convert.ToDouble(strNumberB));</span><br><span class="line">                    else</span><br><span class="line">                        strResult = &quot;除数不能为0&quot;;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;结果是：&quot; + strResult);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;您的输入有错：&quot; + ex.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//业务逻辑与界面逻辑分开，降低耦合</span><br><span class="line">//Operation运算类</span><br><span class="line"></span><br><span class="line">public class Operation</span><br><span class="line">&#123;</span><br><span class="line">    public static double GetResult(double numberA, double numberB, string operate)</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0d;</span><br><span class="line">        switch (operate)</span><br><span class="line">        &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                result = numberA + numberB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                result = numberA - numberB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                result = numberA * numberB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;/&quot;:</span><br><span class="line">                result = numberA / numberB;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端代码</span><br><span class="line"></span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(&quot;请输入数字A：&quot;);</span><br><span class="line">        string strNumberA = Console.ReadLine();</span><br><span class="line">        Console.Write(&quot;请选择运算符号(+、-、*、/)：&quot;);</span><br><span class="line">        string strOperate = Console.ReadLine();</span><br><span class="line">        Console.Write(&quot;请输入数字B：&quot;);</span><br><span class="line">        string strNumberB = Console.ReadLine();</span><br><span class="line">        string strResult = &quot;&quot;;</span><br><span class="line">        strResult = Convert.ToString(Operation.GetResult(Convert.ToDouble(strNumberA),</span><br><span class="line">        Convert.ToDouble(strNumberB), strOperate));</span><br><span class="line">        Console.WriteLine(&quot;结果是：&quot; + strResult);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;您的输入有错：&quot; + ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//使用继承和多态后</span><br><span class="line">//Operation运算类</span><br><span class="line"></span><br><span class="line">public class Operation</span><br><span class="line">&#123;</span><br><span class="line">    private double _numberA = 0;</span><br><span class="line">    private double _numberB = 0;</span><br><span class="line">    </span><br><span class="line">    public double NumberA</span><br><span class="line">    &#123;</span><br><span class="line">        get  &#123;  return _numberA;  &#125;</span><br><span class="line">        set  &#123;  _numberA = value;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public double NumberB</span><br><span class="line">    &#123;</span><br><span class="line">        get  &#123;  return _numberB;  &#125;</span><br><span class="line">        set  &#123;  _numberB = value;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public virtual double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0; </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运算类</span><br><span class="line">class OperationAdd : Operation</span><br><span class="line">&#123;</span><br><span class="line">    public override double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0; </span><br><span class="line">        result = NumberA + NumberB;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OperationSub : Operation</span><br><span class="line">&#123;</span><br><span class="line">   public override double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0;</span><br><span class="line">        result = NumberA - NumberB;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OperationMul : Operation</span><br><span class="line">&#123;</span><br><span class="line">    public override double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0;</span><br><span class="line">        result = NumberA * NumberB;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OperationDiv : Operation</span><br><span class="line">&#123;</span><br><span class="line">    public override double GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        double result = 0;</span><br><span class="line">        if (NumberB==0)</span><br><span class="line">            throw new Exception(&quot;除数不能为0。&quot;);</span><br><span class="line">        result = NumberA / NumberB;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//简单运算工厂类实现</span><br><span class="line"></span><br><span class="line">public class OperationFactory</span><br><span class="line">&#123;</span><br><span class="line">    public static Operation createOperate(string operate)</span><br><span class="line">    &#123;</span><br><span class="line">        Operation oper = null;</span><br><span class="line">        switch (operate)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                oper = new OperationAdd();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                oper = new OperationSub();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                oper = new OperationMul();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;/&quot;:</span><br><span class="line">                oper = new OperationDiv();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端代码</span><br><span class="line">Operation oper;</span><br><span class="line">oper = OperationFactory.createOperate(&quot;+&quot;);</span><br><span class="line">oper.NumberA = 1;</span><br><span class="line">oper.NumberB = 2;</span><br><span class="line">double result = oper.GetResult();</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="代码的目标："><a href="#代码的目标：" class="headerlink" title="代码的目标："></a>代码的目标：</h6><ul>
<li>可维护</li>
<li>可复用</li>
<li>可扩展</li>
<li>灵活性</li>
</ul>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>学习面向对象的分析设计编程思想，通过封装、继承、多态降低程序的耦合性，使用设计模式使得程序更加灵活，容易修改，并且容易复用。</p>
]]></content>
      <categories>
        <category>learn designPattern</category>
        <category>简单工厂模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>学习springboot-1</title>
    <url>/blog/2019/11/16/springboot-1/</url>
    <content><![CDATA[<h1 id="springboot注解的使用"><a href="#springboot注解的使用" class="headerlink" title="springboot注解的使用"></a>springboot注解的使用</h1><p><code>@Value</code>：写在定义单个变量前，与<code>application.yml</code>中的相应位置相对应。</p><a id="more"></a>
<p><code>@Component</code>：表明该类是一个组件，表明后才能使用<code>@Autowired</code>进行自动装配。</p>
<p><code>@ConfigurationProperties</code>：<code>@Value</code>的升级版，直接把一个类的所有变量与<code>application.yml</code>的相应变量组相对应。</p>
<p><code>@RestController</code>：等于<code>@ResponseBody</code>+<code>@Controller</code>作用之和</p>
<p><code>@PathVariable</code>：获取url中的数据，用这种方式获取rest风格的url中的id值，如</p>
<p>访问的url为：<code>localhost:8080/execution/100</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/execution/&#123;id&#125;&quot;)</span><br><span class="line">public String methods(@PathVariable(&quot;id&quot;)Integer id)&#123;</span><br><span class="line">     return &quot;id=&quot;+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>@RequestParam</code>：获取请求参数的值，</p>
<p>访问的url为：<code>localhost:8080/execution?id=100</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/execution&quot;)</span><br><span class="line">public String methods(@RequestParam(&quot;id&quot;)Integer id)&#123;</span><br><span class="line">     return &quot;id=&quot;+id;</span><br><span class="line">&#125;</span><br><span class="line">//这里的参数可以不传或设置默认值</span><br><span class="line">@GetMapping(&quot;/execution&quot;)</span><br><span class="line">public String methods(@RequestParam(value= &quot;id&quot;, required = false, defaultValue = &quot;0&quot;)Integer id)&#123;</span><br><span class="line">     return &quot;id=&quot;+id; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>@Transactional</code>：开启事务，注意这只是对java程序的设置，真正能否实现还得看数据库是否支持事务，如发现开启事务后，数据库仍未支持事务，这是可能需要更换数据库引擎（如<code>mysql</code>的设置成<code>InnoDB</code>）。<code>navicate</code>更改方式如下（先打开<code>设计表</code>，全选所有字段后，然后选择<code>选项</code>）。</p>
<p><img src="/imgs/springboot-1/springboot1.png" alt>_</p>
<p><code>@Valid</code>注解与实体类中对应属性上的限制注解，如<code>@Min</code>、<code>NotEmpty</code>等相结合，实现表单验证功能。</p>
<p>如<code>@Min(value = 18,message = &quot;msg&quot;)</code> 表明最小值为18，如错误则设置<code>message</code>为<code>msg</code>，同时在<code>@Valid</code>使用后，添加<code>BindingResult bindingResult</code>参数，通过<code>BindingResult</code>的<code>hasErrors</code>方法判断是否错误，同时可以通过<code>BindingResult</code>的<code>getFieldError</code>的<code>getDefaultMessage</code> 方法得到实体类中设置的<code>message</code>值。</p>
<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Girl实体类中</span><br><span class="line">@Min(Value = 18,message = &quot;年龄不能小于18岁&quot;)</span><br><span class="line">private Integer age;</span><br><span class="line"></span><br><span class="line">//调用表单方法中</span><br><span class="line">public void methods(@Valid Girl girl,BindingResult bindingResult)&#123;</span><br><span class="line">	if(bindingResult.hasErrors())&#123;</span><br><span class="line">		System.out.println(bindingResult.getFieldError().getDefaultMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AOP统一处理日志请求"><a href="#AOP统一处理日志请求" class="headerlink" title="AOP统一处理日志请求"></a>AOP统一处理日志请求</h1><ul>
<li><p>AOP是一种编程范式，与语言无关，是一种程序设计思想。</p>
<p>   ~  面向切面（AOP）Aspect Oriented Programing</p>
<p>   ~  面向对象（OOP）Object Oriented Programing</p>
<p>   ~  面向过程（POP）Procedure Oriented Programing           <em>如C语言。</em></p>
</li>
</ul>
]]></content>
      <categories>
        <category>learn_springboot</category>
      </categories>
  </entry>
  <entry>
    <title>test_markdown</title>
    <url>/blog/2019/11/15/test-markdown/</url>
    <content><![CDATA[<p><code>显示什么呢</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">here is </span><br><span class="line">the code </span><br><span class="line">of the </span><br><span class="line">program</span><br></pre></td></tr></table></figure><h1 id="这是一级标题？"><a href="#这是一级标题？" class="headerlink" title="这是一级标题？"></a>这是一级标题？</h1><hr><h2 id="二级标题？"><a href="#二级标题？" class="headerlink" title="二级标题？"></a>二级标题？</h2><a id="more"></a>



<h3 id="三级标题？"><a href="#三级标题？" class="headerlink" title="三级标题？"></a>三级标题？</h3><p><em>我是斜体吗</em></p>
<p><strong>我加粗了吗</strong></p>
<hr>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong><code>总结：</code></strong></h1><p>1.使用tags、categories、标题（#）时记得符号后需要一个空格。</p>
<p>如 tags：      # 一级标题   ##   二级标题    ###  三级标题</p>
<p><code>- tags</code></p>
<p>2.斜体 为**， 中间加上斜体内容</p>
<p>3.加粗为** **，中间加上需要加粗的内容</p>
<p>4.高亮块为``</p>
<p>5.代码块为 ``````</p>
]]></content>
      <categories>
        <category>learn-hexo</category>
      </categories>
      <tags>
        <tag>test-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>记录hexo安装和使用的步骤</title>
    <url>/blog/2019/11/14/%E8%AE%B0%E5%BD%95hexo%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>​        这是正式的第一篇文章，想用来介绍晚上使用hexo框架搭建这个博客的过程。</p><p>​        首先，你的电脑需要有git和nodejs这两个工具，可到各自的官网下载，下载完后在命令行下输入git、node、npm验证</p><a id="more"></a>

<p><img src="/blog/imgs/first/git.png" alt></p>
<p><img src="/blog/imgs/first/node.png" alt></p>
<p><img src="/blog/imgs/first/npm.png" alt></p>
<p>​        安装完后新建一个博客的目录文件，在我这里为D:/code/blog，</p>
<p>通过命令行跳转到该项目，注意由C盘到D盘的命令为D:  ，而不是cd d:  ,或其他。</p>
<p><img src="/blog/imgs/first/c_d.png" alt></p>
<p>​        然后通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>​        初始化改目录，使其成为一个hexo博客文件夹。</p>
<p>​        接着通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n test</span><br></pre></td></tr></table></figure>

<p>创建一篇名为test的新文章。此时会在blog/source/_posts目录下新建test.md文件，即为该文章的源文件。</p>
<p>​        编写好文章内容后，通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>清理文件夹内容，然后通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>生成文章在hexo的可展示的文件，在blog/public/2019的文件夹下。</p>
<p>最后通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>启动服务器。这样在localhost:4000下就能访问到博客的主页了（默认端口是4000，如不可访问可能是其他端口冲突）。</p>
<p>部署到github的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo学习与使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/blog/2019/11/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>这个是Eoogle的第一篇博客</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>categories测试</category>
        <category>categories test</category>
      </categories>
      <tags>
        <tag>tags</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
